---
title: bash基本运算
date: 2015-07-02 19:17:21
categories: shell
tags:
    - 脚本编程
    - bash
---

![](http://p7wcdketk.bkt.clouddn.com/18-5-2/3137327.jpg)

<!-- more -->

## 运算符 ##

### 四则运算符 ###

四则运算符与我们小学数学中的运算符相同：

|运算符|	作用|
|:-|:-|
|+|	加|
|-|	减|
|*|	乘|
|/|	除|
|%|	取模|

`+`，`-`，`*` 的作用相信已经不用再向大家做过多的解释。

这里的除（`/`）的结果只能得到商，这里的取模取得的是余数。

注意：shell 内置使用的运算方式 `expr` 只能做整数之间的运算，结果也是整数。想要实现小数（也就是浮点数）之间的运算需要特殊的方法，在后续的运算命令中将详细讲解
同样这里的 `+` 与 `-` 也可以表示数值的正负，当然符号与数值必须紧密相连。

在 shell 中上述的符号都有其特殊的意义，所以 shell 中无法直接进行数值的运算，所以需要借助一些命令来实现，比如`expr`：

![](http://p7wcdketk.bkt.clouddn.com/18-5-2/42453500.jpg)

### 逻辑运算符 ###

逻辑运算符主要就是与、或、非三种，大家之前应该都接触过：

非（以该符号表示：`!`）：也就是相反的意思，真反过来就是假，假反过来就是真；
与（以该符号标示：`&`）：也就是并且的意思，也就是 a 为真并且 b 为真，这样整体才是真，有一个假整体都是假；
或（以该符号标示：`|`）：也就是或者的意思，也就是 a 为真或者 b 为真，只要其中一个是真整体就是真的。

```bash
# 两者都不为 0，取值前者
expr 1 \& 2
#注意转义
# 后者为 0，值为 0
expr 2 \& 0
#注意转义
```

### 关系运算符 ###

关系运算符便是大家所常见的 `>`，`<`，`<=`，`>=`，`=`：

> 注意：在 shell 中 `<`，`>` 有重定向的特殊意义，所以这里需要使用转义符号告知 shell 关闭其特殊的意义。

## 运算命令 ##

上文我们提到过 Linux 中我们是不能直接进行运算的，我们需要借助一些命令才能进行数值的计算，常用的命令有：

|运算|作用|
|:-|:-|
|expr|可用于整数运算，为内置命令来自于 Unix|
|$[ ]|简单算术运算，是较老版本|
|(( ))|用于简单算术运算，bash 中的算术扩展，是 $[] 的升级版|
|let|运行简单的运算同时赋给变量，为内置命令|
|declare|定义变量值和属性，-i 参数可用于赋给变量一个整数属性|
|bc|Linux 下的计算器程序，整数运算及小数运算，需要额外安装|

### expr 命令 ###

`expr` 是一个非常古老的命令，来自于早起的 Unix 系统，非常简单的一个命令，在上述的例子中大家都有所感受。使用该命令的时候一定要注意其格式，因为它是通过参数的逐步读取来获取每一步的需要操作，所以参数之间的空格不要忘记.

需要注意的有：

- 在 `expr` 中是没有幂运算的，例如 2 的多少次方。
- 在 `expr` 中是没有小数运算的（也就是浮点数运算）。

### (()) 运算命令 ###

`$[] `是非常早期的 bash 语法，但是处理性能或者功能性上的弱势使得后期人们对其优化与功能上的增强，从而出现了 `(())`，官方更多的推荐大家使用` (())`，淘汰 `$[]`，`$[] `的存在只是为了让一些老版本的脚本不会报错而保留。而` (())` 与 `expr` 相比的话将更人性化许多，我们不必在考虑空格的存在，例如：


```bash
# 这里使用 echo 是为了让其将结果输出，添加 $ 是为了这部分能够运行，而不是让 echo 理解成其他意义
echo $((1+1))

# $[] 也能够使用，只是它是历史的包袱，不推荐使用
echo $[1+1]


```

同时在使用 `(())`时，其中的变量不需要使用 `$`，这也是其优化的第一个地方，而在 `expr` 中变量还是需要以正常的方式使用 `$变量名`，这是因为 `expr` 是逐步读取参数所导致，

```bash
# 给一个变量赋值
a=0

# 打印出来
echo $a

# 使用 (()) 为期赋值，我们需要的只是执行里面的表达式，不需要打印，所以不需要 $
((a=a+3))

# 再次查看 a 变量的值
echo $a

# expr 只是执行当前给的参数组合成的表达式，所以需要 $a，并且没有办法为变量赋值，只会输出运算结果
expr $a + 3


```

在 `(())` 中是可以执行幂运算的，例如 2 的 3 次方：


```
# (()) 中幂运算是用 ** 来标示
echo $((2**3))

```


### let 命令 ###

`let` 命令可以说是 `(())` 的命令版本，在 `(())` 中如果不知道可用的参数，可以直接查看 `let` 的参数介绍。 `let` 是内建命令，若是想看其参数介绍需要用 `help let`（内建命令的概念在第一周帮助命令中提及，同时提及的注意点有 help 命令只能在 bash 中运行）

`(())` 相对于 `let` 的优势在于可以不用考虑表达式中的空格问题，而 `let` 则是以空格分隔参数。

同时 `let` 与直接使用 `(())` 一样，表达式执行之后是没有结果返回的，要想看到 `let` 执行的效果需要通过变量去查看：

```bash
# let 不会有结果打印
let 1+1

# 定义变量来验证
b=0
let b++
echo $b

# b++ 的效果等同于 b=b+


```

> 值得注意一点是 `let` 与 `(())` 相对于 `expr` 还有一点优势便是他们可以计算小数，只是精度会达到 16 位，不是很方便


### declare 命令 ###

通过 `declare` 命令的 `-i` 参数我们可以给予其 integer 属性，让其可以有数值计算的能力，同样它是一个内置命令需要通过 `help` 命令才能查看到其简单的说明与常用的参数。

既然 `-i` 是添加可计算的属性，若是想剥夺该属性则需要使用 `+i` 了，这是一个有违我们常规习惯的用法，值得提一下。

```bash
c=3/3

# 查看效果
echo $c
3/3
# 赋予属性
declare -i c

# 查看效果
echo $c
1

```

### bc 命令 ###

`bc` 命令不同于之前所提到的命令，它是一个外部命令，之前的都是系统所自带的，既然是一个外部命令，我们便需要安装该工具：

```bash
apt-get install bc
```

在之前我们提到过 shell 中的 `expr` 计算只能计算整数，`let` 与 `(())` 进化使得运算值中可以有小数，但是其精度并不是很理想，会保留 16 位，这一点 `bc` 很灵活，默认情况下是保留一位，而且精度是可以控制的，所在在对精度要求的情况下我们可以选择 `bc`。

```bash
echo "3 + 3" | bc

# scale 用于控制显示精度
echo "scale=2;1.1*3.3" | bc

```

因为 `bc` 提供的是交互界面，所以在不想使用交互模式的时候可以使用这样的方式，若是使用交互方式的话可以使用 `ctrl + d` 退出:

![](http://p7wcdketk.bkt.clouddn.com/18-5-2/63967258.jpg)


## 条件判断 ##

上面我们提到了关系运算符与逻辑关系与或非，这两者的运用不仅仅是用在算术运算中，我们还常常将其用在条件判断中，常用的条件判断有两种：
   - []
   - [[]]

其实两者的关系就像上述的`$[]` 与 `(())`，也像我们后续将会讲的命令替换` ``` 与 `$()`(反引号容易使人误会，所以官方更推荐 $())。

`[]`其实就是 `test` 命令，`test` 命令不仅仅可以比较两个数值，还可以用来判断文件的类型，字符串的比较等等。

### 数值比较 ###

因为是在命令行中，其判断结果并不会打印出来，所以我们选择通过其退出状态值来判断：

```bash
# 判断 3 大于 2
test 3 -gt 2 

# 判断结果输出
echo $?
0
# 判断 3 大于 5
test 3 -gt 5
1
# 判断 3 小于 5
test 3 -lt 5
0
# [] 就是 test，用 [] 判断值是否相等
[ 3 -eq 4 ]
1
[ 3 -eq 3 ]
0
```

### 文件类型的判断 ###

```bash
# 判断家目录的 Code 是否为目录
[ -d /home/user1/Code ]

# 判断家目录中是否有 shiyanlou 文件
[ -e /home/user1/shiyanlou]

# 判断 .zshrc 是否可读
[ -r /home/user1/.zshrc ]

```

当然不仅如此，当我们有多个判断条件的时候我们还添加逻辑运算符，当我们需要使用与逻辑时我们可以使用 `-a` 参数，当我们需要使用或逻辑的时候可以使用 `-o` 参数，例如：

`[ -e /home/shiyanlou/shiyanlou -o -r /home/shiyanlou/.zshrc ]`

## 特殊运算 ##

### 进制转换 ###

在某些特殊的情况下我们会使用进制之间的运算，例如：

把 10 进制的 11 转换成 2 进制。

```bash
$ echo "obase=2;ibase=10;11"|bc -l
1011
把 2 进制的 1011 转换成 10 进制

$ echo $((2#1011))
11
```


### 随机数 ###

有时候我们需要产生一些随机数，我们可以利用 `$RANDOM` 产生，它不是一个变量，是一个内置的函数，可以生成 0-32767 的随机数。

```bash
$ echo $RANDOM

#产生0-255之间的数字
$ expr $RANDOM / 128
```

除此之外，还可以通过一个更灵活的命令 `shuf` 去生成随机数，该命令通过 `-i` 参数指定范围，通过 `-n` 参数指定你需要的个数：

```bash
shuf -i 100-300 -n 1

shuf -i 10-20 -n 2
```

