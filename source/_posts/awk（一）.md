---
title: awk的基本操作
date: 2016-08-09 18:40:33
categories: shell
tags:
    - awk
    - 脚本编程
---



> AWK 是一种优良的文本处理工具，Linux 及 Unix 环境中现有的功能最强大的数据处理引擎之一，
awk 处理的对象可以是一个文本文件，亦或者是通过管道符传过来的内容。无论什么形式的内容其本质上都是通过一个 for 循环处理，每次读入一行处理，然后转而执行下一行，直到整个文件的每一行都被执行完毕。

# awk的基本操作 #

## 一、awk的模式 ##

### 1、记录和字段 ###

首先来了解两个概念：记录，字段。

例如这样一个表格：

|---|字段1|字段2|字段3|字段4|
|:-|:-|:-|:-|:-|
|记录1|张三|a|b|c|
|记录2|李四|d|e|f|
|记录3|王五|g|h|i|

记录：指这个表中的每一行。这个表有 3 行记录。第一条记录是 “张三 a d c” ，依次类推。

字段：指这个表中的每一列。也就是由字段分隔符所切分出来的每个部分，例如该表若以空格分割，每行有 4 个字段。例如第一行的第一个字段是 “张三” ，依次类推。

### 2、什么是awk的模式 ###

`awk` 所有的操作都是基于 `pattern(模式)—action (操作)` 对来完成的，如下面的形式：
```
pattern {action}
```
你可以看到就如同很多编程语言一样，它将所有的动作操作用一对`{}`花括号包围起来。

- 模式 `pattern` 用于筛选记录，操作 `action` 用于处理字段。
- 其中 `pattern` 通常是表示用于匹配输入的文本的“关系式”或“正则表达式”（若是正则表达式需要使用 `//` 括住）
- `action` 则是表示匹配后将执行的操作。
- 对于 awk 读取的每条记录，如果一个记录与指定模式 Pattern 相匹配，或包含与该模式匹配的字段，那么执行相应的操作 Action 。
- 在一个完整 awk 操作中，这两者可以只有其中一个，如果没有 pattern 则默认匹配输入的全部文本，操作会被应用到每条输入记录。如果没有 action 则默认为打印匹配内容到屏幕。
应用实例

下面的实例带领大家更好地理解 `awk` 的模式以及省略模式和省略操作的区别。

我们先来查看主目录下的文件详细信息：

```bash
cd ~
ll
```

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/38775263.jpg)

使用awk过滤掉我们不想看的目录,只看Desktop文件夹信息：

```bash
ll|awk '/Desktop/{print $0}'
```

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/76609075.jpg)



> 命令中的`/Desktop/`就是模式，`{print $0}`就是操作

> `{print $0}`执行的是打印整行 ，其实不用写，awk的默认操作也即是它

```bash
awk '/Desktop/' <=> awk '/Desktop/{print $0}' #两者效果一样
```

`print`操作可以打印输出指定的字段信息，也就是指定的列，如，想查看`ll`命令输出的第3列和第9列信息，也就是文件的所有者和文件名，可以这样：

```bash
ll | awk '{print $3,$9}'
```
![](http://p7wcdketk.bkt.clouddn.com/18-5-9/96939388.jpg)




### 3、模式类型 ###

在 awk 中有下列几种模式：

- 正则表达式
- 关系表达式
- 组合的 Pattern
- Pattern1,Pattern2
- BEGIN
- END

#### 正则表达式 ####

模式的类型可以为正则表达式，正则表达式的规则需要写在 `//` 中。

比如我们要查询 Desktop 目录下包含 `ge` 或者 `gv` 的记录，可以使用如下命令：

```bash
ll Desktop|awk '/g[ev]/{print $0}' 

```

`~` 表示与正则表达式匹配（可以省略 ~ 号），`!~` 表示与正则表达式不匹配。


```
#查询 Desktop 目录下文件名包含 ge 和 gv 的记录
$ ll Desktop|awk '$9~/g[ev]/{print $0}' 

#查询 Desktop 目录下文件名不包含 ge 和 gv 的记录
$ ll Desktop|awk '$9!~/g[ev]/{print $0}'
```


#### 关系表达式 ####

模式的类型可以为关系表达式。

下表列出了关系运算符

|运算符|含义|
|:-|:-|
|<|	小于|
|<=|小于等于|
|==|等于|
|!=|不等于|
|>=|大于等于|
|>|	大于|

比如我们要查询 Desktop 目录下大于 **800** 字节的文件或者目录，可以使用如下命令：

```bash
$ ls -l Desktop|awk '$5>800{print $0}'
```

#### 组合的模式 ####

逻辑运算符 `||`（或）、`&&`（与）以及 `!`（非）将模式组合，组合后如果求值为真则模式匹配，否则不匹配。

比如我们要查询 Desktop 目录下**大于 800 字节小于 8000 字节的文件或者目录**，可以使用如下命令：

```bash
$ ls -l Desktop|awk '$5 > 800 && $5 < 8000{print $0}' 
```


#### pattern1，pattern2 ####

以 `,`（逗号）隔开的两个 Pattern（模式），为匹配位置指定了一个范围，对从匹配第一个 Pattern 的记录开始，到匹配第二个 Pattern 结束的所有记录执行 Action（操作）。

比如匹配 Desktop 目录下**等于 179 字节的文件/目录，直到等于 767 字节的文件/目录**。可以使用如下命令：

```bash
$ ls -l Desktop|awk '$5==179,$5==767{print $0}' 
```

#### BEGIN ####

`BEGIN` 模式是 awk 的一种特殊的 Pattern，`BEGIN` 模式指定的操作是在读取任何输入之前执行，且只执行一次。使用 `BEGIN` 模式甚至不需要指定输入文件，一般把与数据文件内容无关以及只需要执行一次的部分置于以 `BEGIN` 模式为 Pattern 的 Action 中。

例如：

```
$ ls -l Desktop|awk 'BEGIN{print "1 2 3 4 5 6 7 8 9"}{print}' 
```

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/88757485.jpg)


#### END ####

`END` 模式也是 awk 中一种特殊的 Pattern，`END` 模式指定的操作是在读取所有的输入后执行。

```bash
$ ls -l Desktop|awk '{print}END{print "finish---------"}' 
```

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/858637.jpg)


### 4、命令选项 ###

```
awk [-F fs] [-v var=value] [-f prog-file | 'program text'] [file...]
```

|选项|描述|
|:-|:-|
|-F|预先指定字段分隔符（默认字段分割符是空格）|
|-f|指定 awk 命令要执行的程序文件，或者在不加 -f 参数的情况直接将程序语句放在这里。|
|-v|预先为 awk 程序指定变量|

**-F**

awk 处理文本的方式，是读取每一行，然后将记录分割成一些字段，然后再对这些字段进行处理，默认情况下，awk 以空格作为一个字段的分割符，不过这不是固定的，你可以使用 -F 任意指定分隔符，下面将告诉你如何做到这一点。

比如我们要以 :（冒号）作为一个字段的分隔符。则可以进行如下操作：

```
#以冒号为分割符
$ awk -F: '{print $1}' /etc/passwd

或者
$ awk 'BEGIN{FS=":"}{print $1}' /etc/passwd

```

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/3733034.jpg)


**-f**

新建一个名叫 testf 的文件，实现用 awk 打印出 hello shiyanlou：
```
$ vim testf
BEGIN{print "yahoo~~~"}
```

我们要执行这个 awk 命令，就要加上 -f 选项，后面跟上文件名：

```
$ awk -f testf
```
> 实际和执行`awk 'BEGIN{print yahoo~~~}'`是一个效果


**-v**

将外部变量`var`的值传入awk的`variable`中
```
$ var=100
$ echo |awk -v variable=$var '{print variable}'

# 输出结果为：100
```


### 5、内置变量 ###

awk 中有许多系统变量或内置变量。awk 有两种类型的系统变量：

- 第一种内置变量的类型用于 awk 的控制，例如分隔符等。
- 第二种内置变量的类型用于信息的传达，例如当前记录中字段的数量，当前记录的数量等。

#### awk 常用的内置变量 ####

|变量名|说明|
|:-|:-|
|FILENAME|当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串|
|$0|当前记录的内容|
|NF|当前记录字段数，列数|
|$N|N 表示字段号，最大值为 NF 变量的值|
|FS|字段分隔符，默认为" "空格|
|RS|	输入记录分隔符，默认为"\n"，即一行为一个记录|
|NR|已经读入的记录数，行数|
|FNR	当前输入文件的记录数，请注意它与 NR 的区别。 对于 NR，读取不同文件，NR 是一直累计的。 但是对于 FNR，读取不同文件，开始下一个文件的时候 FNR 又从 1 开始了。在流程控制一节我们以实例讲解它们之间的区别|
|OFS|输出字段分隔符，默认为" "空格|
|ORS|输出记录分隔符，默认为"\n"|
|ARGC|命令行参数的数目|
|ARGIND|命令行中当前文件的位置（从0到ARGC-1）|
|ARGV|命令行参数的数组|
我们来通过下面的方法来输出常用的内置变量的值，更好地理解常用的几个内置变量的含义。



新建一个测试文本 test.txt，输入如下内容：

```
hello this is wyman
welcome to myplace
this's a test file
would you like something to drink coffee,tea,or coco-cola
```

新建一个脚本文件 test.sh，输入如下内容：
```
# 使用默认的分隔符切分，打印各个变量的值
awk 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  test.txt

# 使用 ‘ 单引号作为分隔符切分，打印各变量的值
awk -F\' 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  test.txt

awk '{print NR,FNR,$1,$2,$3}' test.txt

#修改分隔符
awk '{print $1,$2,$5}' OFS=" $ "  test.txt
```


![](http://p7wcdketk.bkt.clouddn.com/18-5-9/22116790.jpg)

### 6、应用实例 ###

#### 分隔符的修改 ####

新建文本：

```
1 2 3 4
```

**实现将文本每个字段显示为一行**：

```
$ awk '{
> print $1 "\n" $2 "\n" $3
> }' test

# 或者
$ awk '{
> OFS="\n"
> print $1, $2, $3
> }' test
```

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/58543443.jpg)

![](http://p7wcdketk.bkt.clouddn.com/18-5-9/93013146.jpg)

> OFS 是 awk 内建的变量。



> OFS 表示输出时的字段分隔符，默认为" "（空格）。



> 如上图所见，我们将字段分隔符设置为\n换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。



> 然后是$N 其中 N 为相应的字段号，这也是 awk 的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了$3。除此之外另一个这里没有出现的$0，它表示引用当前记录（当前行）的全部内容。



**以`.`为分隔符处理文本**：

新建text2.txt文本，内容为:
```
www.wyman.wang
```


```bash
$ awk -F'.' '{
> print $1 "\t" $2 "\t" $3
> }' test

# 或者
$ awk '
> BEGIN{
> FS="."
> OFS="\t"  # 如果写为一行，两个动作语句之间应该以";"号分开  
> }{
> print $1, $2, $3
> }' test
```

![](http://p7wcdketk.bkt.clouddn.com/18-5-10/74626119.jpg)

> 说明：这里的 -F 参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。



> 我们需要注意的是除了指定 OFS 我们还可以在 print 语句中直接打印特殊符号如这里的 \t。



> 在第二种方法中展示了预先指定分隔符的另一种方式，即使用 BEGIN ，就这个表达式会在所有的操作之前，这里是 FS 设置了以 "." 代替默认的" "空格
