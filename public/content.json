{"meta":{"title":"Wyman's","subtitle":"论总结的重要性","description":"保持好奇 | 适当谦虚","author":"Wyman","url":"http://wyman.wang"},"pages":[{"title":"categories","date":"2018-02-27T07:56:11.000Z","updated":"2018-04-27T06:21:39.828Z","comments":false,"path":"categories/index.html","permalink":"http://wyman.wang/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-27T07:55:08.000Z","updated":"2018-04-27T06:21:43.281Z","comments":false,"path":"tags/index.html","permalink":"http://wyman.wang/tags/index.html","excerpt":"","text":""},{"title":"ABOUT","date":"2018-03-02T09:17:03.000Z","updated":"2018-04-27T09:27:49.594Z","comments":true,"path":"about/index.html","permalink":"http://wyman.wang/about/index.html","excerpt":"","text":"魔系运维 | 隔壁老王 | 爱折腾，爱分享 | 人畜无害 | 娇羞慢热"}],"posts":[{"title":"expect初体验","slug":"expect初体验","date":"2018-04-11T01:07:48.000Z","updated":"2018-04-27T09:08:08.524Z","comments":true,"path":"2018/04/11/expect初体验/","link":"","permalink":"http://wyman.wang/2018/04/11/expect初体验/","excerpt":"前言使用命令行与机器打交道，难免会出现需要交互的时候，比如用passwd修改密码，会提示你输入两遍密码确认；比如用ssh访问远程机器，会要求输入密码，这些都需要人工手动参与执行操作。但很多无人值守的情况下如何完成交互，这里，我们可以使用expect。 通过expect，可以让我们将预先需要准备手工干预的部分提前备好，等到出现相应提示信息（或返回信号），将我们准备的参数与要执行的语句以send命令交给机器。所以在使用expect前，你需要详细了解你要完成的任务的具体流程，详细到什么时候会出现什么提示。","text":"前言使用命令行与机器打交道，难免会出现需要交互的时候，比如用passwd修改密码，会提示你输入两遍密码确认；比如用ssh访问远程机器，会要求输入密码，这些都需要人工手动参与执行操作。但很多无人值守的情况下如何完成交互，这里，我们可以使用expect。 通过expect，可以让我们将预先需要准备手工干预的部分提前备好，等到出现相应提示信息（或返回信号），将我们准备的参数与要执行的语句以send命令交给机器。所以在使用expect前，你需要详细了解你要完成的任务的具体流程，详细到什么时候会出现什么提示。 语法expect遵循的是tcl语言的语法，一条Tcl命令由空格分割的单词组成. 其中, 第一个单词是命令名称, 其余的是命令参数: cmd 参数1 参数2 参数3... 1、$符号 $代表变量的值 2、[] []方括号执行了一个嵌套的命令，类似shell中的 `cmd`或(())或$() 3、“” “blablabla” 双引号标记为命令的一个参数 4、{} {blablabla} 花括号也标记为命令的一个参数，但是花括号内的其他符号不被解释 常用命令1、spawn spawn后接要执行的语句，也就是你需要向linux系统发出的shell命令 2、expect expect为等待的信息，也是系统向用户反馈的提示 3、send 向系统发送交互的值，可以是一个shell命令，也可以是为expect等待的提示所输出的答复，比如ssh host 之后，第一步应该是先回答yes/no，此处可以用send回复yes 4、set 通过set定义变量并赋值 5、interact 执行了interact后，终端会把操作权限交给控制台，可以手动进行剩余部分的操作；比如我们通过ssh到远程主机后，在ssh、输密码阶段可以用expect完成，当连接成功并登录远程主机后，剩余的部分我们希望自己手动进行其他的操作，这时可以在expect脚本后边加上interact 6、expect eof expect eof表示捕获终端输出信息的终止，通常一个自动化任务往往以interact或expect eof作为结尾 7、exp_continue 使用exp_continue后，会重新从当前expect块的开始重新执行，可以简单理解问while循环的continue 举几个栗子1、切换用户 123456#!/usr/bin/expect -f //这个expect的路径就是用which expect 查看的结果 spawn su - nginx //切换用户expect \"password:\" //提示让输入密码send \"testr\" //输入nginx的密码interact //操作完成 2、ssh到远程机器 1234567891011#!/usr/bin/expect set timeout 5set server [lindex $argv 0] #传递参数1set user [lindex $argv 1] #传递参数2set passwd [lindex $argv 2] #传递参数3spawn ssh -l $user $serverexpect &#123;&amp;quot;(yes/no)&amp;quot; &#123; send &amp;quot;yesr&amp;quot;; exp_continue &#125;&amp;quot;password:&amp;quot; &#123; send &amp;quot;$passwdr&amp;quot; &#125;&#125;expect &amp;quot;*Last login*&amp;quot; interact","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"},{"name":"shell","slug":"Linux-OPS/shell","permalink":"http://wyman.wang/categories/Linux-OPS/shell/"}],"tags":[{"name":"expect","slug":"expect","permalink":"http://wyman.wang/tags/expect/"},{"name":"自动交互","slug":"自动交互","permalink":"http://wyman.wang/tags/自动交互/"},{"name":"bash","slug":"bash","permalink":"http://wyman.wang/tags/bash/"}]},{"title":"都是SELinux惹的祸","slug":"SELinux惹的祸","date":"2018-04-02T10:30:14.000Z","updated":"2018-04-26T03:13:15.541Z","comments":true,"path":"2018/04/02/SELinux惹的祸/","link":"","permalink":"http://wyman.wang/2018/04/02/SELinux惹的祸/","excerpt":"","text":"最近半个月，在进行服务器配置改造的过程中，接二连三遇到一些诡异的问题： RSH无密码访问各项配置正确，却死活不成功 ldap各项配置正确，却死活不成功 nfs挂载各项配置正常，却死活不成功 还有那啥啥啥（对，什么都不顺），依旧死活不成功 要不是突然想起SELinux，还真以为是水逆惹的祸，如果你都不知道这货，来来来，SELinux了解一下 作为一个以增强访问安全策略为目标的模块，这货如同bug一般的存在，经常干扰应用程序的正常运行，这一点和它的编写者——美国国家安全局（NSA）——非常类似，一个喜欢打着维护国家安全的旗号四处扰乱秩序的古惑仔。 所以，如果你有什么配置看起来都很正常却死活不成功的时候，试试看是不是SELinux在作祟：查看： 12345getenforce #enforcing #开启状态 #permissive #宽容模式 #Disabled #关闭状态 关闭： setenforce 0 #临时关闭，进入permissive，重启失效 vi /etc/selinux/config #永久关闭，重启生效 ... SELINUX=disabled 关闭之后，一了百了 当然，关闭之前你得确认你的环境不需要SELinux的介入也能得到必要的安全保障。","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"SELinux","slug":"SELinux","permalink":"http://wyman.wang/tags/SELinux/"}]},{"title":"谁是谁的过客","slug":"谁是谁的过客","date":"2018-03-28T11:25:06.000Z","updated":"2018-04-26T03:13:15.894Z","comments":true,"path":"2018/03/28/谁是谁的过客/","link":"","permalink":"http://wyman.wang/2018/03/28/谁是谁的过客/","excerpt":"","text":"A 今天，一个朋友离开了SZ，隔着朋友圈都能感受到他此刻躺在卧铺车厢上的百感交集，我俩在五年前的5月认识，又在五年前的七月一块来到这座城市 小伙子比我年少5岁，5年前刚毕业时那叫一个青春活力，阳光四射，说话就像机关枪，站他边上我都能感受到他的澎湃，就像十年前的我 17年末，这哥们维持了一年多的爱情，终于在“前未来岳母”的制约下，夭折了。那之后，小伙的朋友圈只剩转发的鸡汤文，和他的脸色一样，根本不能看。 B 今天，入职11个月的老乡辞职了，在入职新东家之前，他说要给自己放几天假，好好逛逛SZ 去年5月，他第一次来到这座城的时候，孤身一人，没有亲戚也没有朋友，下了火车带着大包小包，找了就近的个城中村，钻了进去，租了个只有一张床的大单间。 两天后我们成了同事，一直到今天生活依旧两点一线，当然，也依旧孤身一人。 C 隔壁部门常有业务往来的林君也要走了，我们亲密无间地合作了3年多 这小哥平时喜欢小酌两杯，一个人喝酒枯燥，于是经常和三五基友们远程视频一块豪饮；也爱泡茶，屁点大的办公桌上居然放着三个茶宠四罐茶叶；此人还好书法，不论硬笔、毛笔，都写得了一手楷书、行草。 一个1993年的小伙，活出了1493年流浪侠客的气质。 年方21岁入的职，关于这份工作他有清晰的认识，在入职时就明确知道，这份工作不过是他用于了体验职场运作与处世方法的一次“渡劫” 三年时间的基础设施运维工作，枯燥乏味，还时不时通宵，但他也没抱怨过，兢兢业业地干着。 如今，他觉得这些年的经验攒够了，于是答应“舅舅”，回归了他的开发商家族企业。 D 2018年，距离我第一次接触这座城市，刚好十年，而且那次初次见面，也在三月 彼时，这城市甩给我的只有“快节奏”、“路人冷漠脸”、“我擦，公交车开好快”、“房价真TM贵”这些个关键词 如今，除了上述最后一个坚定不动摇，其他都见怪不怪了 十年相识，五年相知 所谓来了就是SZ的人，不过过客而已 当然，相对而言，这座城也仅仅是我们人生中的一站而已。","categories":[{"name":"生活","slug":"生活","permalink":"http://wyman.wang/categories/生活/"}],"tags":[]},{"title":"老骥伏枥，尚能饭否？","slug":"老骥伏枥，尚能饭否？","date":"2018-03-23T10:08:07.000Z","updated":"2018-04-26T03:13:15.889Z","comments":true,"path":"2018/03/23/老骥伏枥，尚能饭否？/","link":"","permalink":"http://wyman.wang/2018/03/23/老骥伏枥，尚能饭否？/","excerpt":"","text":"欲望得不到满足而失控，蔓延到全身，化作焦虑和烦躁 镜子中的自己，满眼的物欲和贪婪，佛教中所说的五毒贪、嗔、痴、慢、疑五种心，似乎在我身上体现得都很彻底 当然，所带来的结果也很彻底。 但所谓天助自助之人，不论生活怎样的困顿和迷茫，依旧顽强学习和积极向上， 保持着上进的心不变，如果老天没有给到自己一些奖励 那么找个镜子，独自给自己一些掌声总是可以的吧。 当然，又或者自己确实努力不到位？所以，过得不好只是活该 如果是这样，掌声之后，反手再给自己一记耳光吧","categories":[{"name":"生活","slug":"生活","permalink":"http://wyman.wang/categories/生活/"}],"tags":[]},{"title":"在hexo中加入liveRe(来必力)评论功能","slug":"在hexo中加入liveRe评论功能","date":"2018-03-02T08:31:51.000Z","updated":"2018-04-26T03:13:15.870Z","comments":true,"path":"2018/03/02/在hexo中加入liveRe评论功能/","link":"","permalink":"http://wyman.wang/2018/03/02/在hexo中加入liveRe评论功能/","excerpt":"","text":"本计划用畅言，但要进行备案，直觉告诉我此处有坑，发现另外一个不错的评论系统——“来必力”——界面Q弹清爽，更重要的是：在next主题的5.1.4版本中已集成liveRe插件，只需简单一个步骤即可添加liveRe评论功能———————————————————————————————————————————————————————————— 注册并安装City版(看这猥琐又不失可爱的画风) 在“管理页面”中选择安装City版 配置livere_uid一系列的设置后，在“管理页面”-&gt;“代码管理”中的“data-uid”变量就是我们需要的关键值，将该值复制到Next主题配置文件中的livere_uid:即可","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wyman.wang/tags/hexo/"},{"name":"liveRe","slug":"liveRe","permalink":"http://wyman.wang/tags/liveRe/"}]},{"title":"信仰的力量","slug":"信仰的力量","date":"2018-02-12T13:56:01.000Z","updated":"2018-04-26T03:13:15.544Z","comments":true,"path":"2018/02/12/信仰的力量/","link":"","permalink":"http://wyman.wang/2018/02/12/信仰的力量/","excerpt":"","text":"老婆孩子不在家，终于可以安静地把《冈仁波齐》看完 片子讲述的是藏民扎堆在父亲去世后决定完成父亲的遗愿，带着叔叔去拉萨和神山冈仁波齐朝圣的故事 剧情很平静，平静得近乎一部纪录片，但反映出来的信仰的力量却真实有力 记得有一幕，扎堆他们在朝圣的路上遇到一片水洼，几个人停下来犹豫了一下 其中一个人说，“要不我们磕过去吧”，很快大家就达成一致，“好啊，我们磕过去吧” 于是一行人脱下外套，大冷天穿着单衣，在积水的路面上就这么磕着头过去了 这一幕让我泪目，这是怎样的一种纯粹 这一行人，有孕妇、老人、孩子、屠夫，大家怀揣着各自纯粹而善良的愿望踏上这朝圣之路 一路上没有抱怨，彼此相互扶持、帮助，闲暇时间一起念经、唱歌跳舞 我很不理解他们为何要选择走上这么苦的一条路 看到后来，藏民们代人磕头付房费，去洗车店、工地打工挣朝圣的盘缠 乃至最后杨培爷爷的去世，才让我顿悟 信仰对于他们，是生命的意义所在，是和吃喝拉撒睡一样不可或缺的一部分，是像呼吸一样自然而然的存在 不怒不嗔，心无旁骛，跪着走完2000公里 这应该就是信仰带来的力量","categories":[{"name":"生活","slug":"生活","permalink":"http://wyman.wang/categories/生活/"}],"tags":[{"name":"冈仁波齐","slug":"冈仁波齐","permalink":"http://wyman.wang/tags/冈仁波齐/"}]},{"title":"北京，北京","slug":"北京，北京","date":"2018-02-09T02:27:09.000Z","updated":"2018-04-26T03:13:15.584Z","comments":true,"path":"2018/02/09/北京，北京/","link":"","permalink":"http://wyman.wang/2018/02/09/北京，北京/","excerpt":"","text":"前两天出差北京，除了雾霾变少、安保加强了之外，首都依旧别来无恙。 趁着时间空隙，把故宫给走马观花逛了一趟，淡季门票40块，40块钱逛一下午，一下午只逛了全景的一半，40块钱你买不了吃亏，买不了上当，绝对的良心价 故宫的雕龙美到原地炸裂，排水的螭龙栩栩如生，让人爱不释手，我十八般花样来回揉搓，就差高潮了 九龙大石雕我恨不得整个人趴上去，底部的海水江崖美到飞起 啊~~我是对石雕真的毫无抵抗力啊","categories":[{"name":"生活","slug":"生活","permalink":"http://wyman.wang/categories/生活/"}],"tags":[]},{"title":"故障：ldapadd 报错","slug":"故障：ldapadd-报错","date":"2018-01-03T07:01:14.000Z","updated":"2018-04-26T03:13:15.887Z","comments":true,"path":"2018/01/03/故障：ldapadd-报错/","link":"","permalink":"http://wyman.wang/2018/01/03/故障：ldapadd-报错/","excerpt":"","text":"Can’t contact LDAP server使用LDAPADD配置LDAP用户的时候，突然报错： 1ldap_sasl_bind(SIMPLE): Can&apos;t contact LDAP server (-1) 原因在于：使用的主机名称与dc名不一致导致的 解决办法：用 -h 参数指定主机名，-p 参数指定端口号389 1ldapadd -x -D cn=Manager,dc=my-domain,dc=com -W -f XXX/XX.ldif -h MYHOSTNAME -p 389 Invalid credentials另一个报错： 1ldapadd ldap_bind: Invalid credentials (49) 原因：可能在于配置目录信息不一致 解决办法： 清空/etc/openldap/slapd.d/下的所有文件 rm -rf /etc/openldap/slapd.d/* 重新进行一次slaptest测试，写入/etc/openldap/slapd.d/ slaptest -f /etc/openldap/slapd.conf -F /etc/openldap/slapd.d","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"LDAP","slug":"LDAP","permalink":"http://wyman.wang/tags/LDAP/"}]},{"title":"来来来，SELinux了解一下","slug":"关于SELinux（一）","date":"2017-08-11T07:39:08.000Z","updated":"2018-04-27T09:24:21.276Z","comments":true,"path":"2017/08/11/关于SELinux（一）/","link":"","permalink":"http://wyman.wang/2017/08/11/关于SELinux（一）/","excerpt":"SELinux是个神奇的东西，这货幽灵般地存在内核中，经常让我们的程序挂得莫名其妙。","text":"SELinux是个神奇的东西，这货幽灵般地存在内核中，经常让我们的程序挂得莫名其妙。 参考鸟哥私房菜《第十六章、程序管理與 SELinux 初探》： 来头SELinux 来头不小，它是由美国国家安全菊——NSA开发诞生的，它的诞生主要是用于解决内部程序及资源误用而产生的事故，是一种系统内部控制手段，用于管理系统内应用的存取控制。 在之前，先了解并区分一下自主式访问控制 (Discretionary Access Control, DAC)与强制式访问控制 (Mandatory Access Control, MAC) 自主式访问控制通常情况下，我们对Linux文影件的权限可以分为rwx三种，DAC就是根据文件所带的rwx属性来决定其是否具有可读可写的能力，但DAC的缺点也很明显： root权限过大。如果某个程序的权限属于root，而如果一个普通用户获得了这么一个具有root权限的程序，他就有可能通过这个程序实施系统破坏 文件系统的权限可以任意更改。如果某个目录的权限设置为777，那么任何人都可以对这个目录进行任意操作。 强制式访问控制MAC将程序和路径的权限进行了管控，即是是root，在使用不同的程序时，你所能获取到的权限也不一定是root，而是要看该程序的设定来确定你对该路径具有怎样的权限。也就是说，MAC将控制主体由用户转向了程序。每个路径都有其所对应的主体程序，于是，在MAC的限制下，每个程序的活动范围变小了，比如，我们在开启SELinux的情况下会发现，apache只认可/var/www/html这个目录下的页面，所有设置到其他路径下的页面都无法打开。因为httpd程序只能在/var/www/下进行访问，而出了这个路径，其他目录也得要设置为httpd所能访问的类型才可以。MAC好比一个看不见的牢笼，将httpd圈在了我们所设定的范围内，架设apache真的被别有用心的人获取了控制权，他也没法访问我们系统内的其他文件。这也是我前面说到的，SELinux强调内部程序访问管控，缩小程序的权限范围。如图： security Context(安全上下文)从字面意思很难理解这个概念，我们可以把它想象为一个文件的rwx属性，比如一个文件通过ls -l来查看它具有哪些rwx属性，我们可以使用ls -Z来查看一个文件具有怎样的安全上下文权限（很拗口）： for了个example: 1234567891011121314151617#查看/root目录下各个文件的安全上下文[root@master ~]# ls -Z-rw-------. root root **system_u:object_r:admin_home_t:s0** anaconda-ks.cfgdrwxr-xr-x. root root **system_u:object_r:admin_home_t:s0** Badduserdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Desktopdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Documentsdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Downloadsdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** expect_testdrwxr-xr-x. root root **system_u:object_r:admin_home_t:s0** GITLAB-rw-------. root root **system_u:object_r:admin_home_t:s0** initial-setup-ks.cfgdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Musicdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Picturesdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Publicdrwxr-xr-x. root root **system_u:object_r:admin_home_t:s0** scripts_testdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Templatesdrwsr-xr-x. root admin **system_u:object_r:admin_home_t:s0** testdrwxr-xr-x. root root **unconfined_u:object_r:admin_home_t:s0** Videos 中间有三个冒号相连的，就是这个文件的上下文环境。大概可以解释为： 1身份：角色：类型 前面两个我们不关心，其中的类型才是程序能否访问的重点。比如上面，我们在/root路径下的文件，都是admin_home_t这个类型。以鸟哥文章所举的例子为例，我们查看crond程序的上下文环境以及crond所相关的路径的上下文： 12345678910[root@study ~]# ps -eZ | grep cronsystem_u:system_r:crond_t:s0-s0:c0.c1023 1338 ? 00:00:01 crondsystem_u:system_r:crond_t:s0-s0:c0.c1023 1340 ? 00:00:00 atd# 這個安全本文的類型名稱為 crond_t 格式！# 2. 再來瞧瞧執行檔、設定檔等等的安全本文內容為何！[root@study ~]# ll -Zd /usr/sbin/crond /etc/crontab /etc/cron.ddrwxr-xr-x. root root system_u:object_r:**system_cron_spool_t**:s0 /etc/cron.d-rw-r--r--. root root system_u:object_r:**system_cron_spool_t**:s0 /etc/crontab-rwxr-xr-x. root root system_u:object_r:**crond_exec_t**:s0 /usr/sbin/crond 可见，crond程序被设置为可以访问system_cron_spool_t这种类型的路径。 SELinux type的查询和修改查看可以访问的上下文类型我们想知道某个程序的上下文类型能访问哪些对应的类型，该怎么操作，这里需要使用到setools中的sesearch命令 setools可以通过yum完成安装，安装之后即可使用seinfo、sesearch等命令。 12345[root@study ~]# sesearch [-A] [-s 主體類別] [-t 目標類別] [-b 布林值]選項與參數：-A ：列出後面資料中，允許『讀取或放行』的相關資料-t ：後面還要接類別，例如 -t httpd_t-b ：後面還要接SELinux的規則，例如 -b httpd_enable_ftp_server for它个example: 123456789101112131415#查看httpd主体程序的类型，发现为**httpd_exec_t**[root@master www]# ls -Z /usr/sbin/httpd -rwxr-xr-x. root root system_u:object_r:httpd_exec_t:s0 /usr/sbin/httpd...#httpd_exec_t可以访问的类型如下：[root@master www]# sesearch -A -s httpd_exec_tFound 7 semantic av rules: allow file_type noxattrfs : filesystem associate ; allow file_type fs_t : filesystem associate ; allow file_type ramfs_t : filesystem associate ; allow httpd_exec_t httpd_exec_t : filesystem associate ; allow file_type tmpfs_t : filesystem associate ; allow file_type tmp_t : filesystem associate ; allow file_type hugetlbfs_t : filesystem associate ; 修改路径的上下文类型1、chcon——修改目录的上下文类型 12345678[root@study ~]# chcon [-R] --reference=範例檔 檔案選項與參數：-R ：連同該目錄下的次目錄也同時修改；-t ：後面接安全性本文的類型欄位！例如 httpd_sys_content_t ；-u ：後面接身份識別，例如 system_u； (不重要)-r ：後面接角色，例如 system_r； (不重要)-v ：若有變化成功，請將變動的結果列出來--reference=範例檔：拿某個檔案當範例來修改後續接的檔案的類型！ 2、restorecon——恢复默认的上下文类型 restorecon [-Rv] 文件或目录 3、semanage——设置默认的上下文类型 restorecon是恢复至默认的上下文类型，那么通过semanage可以修改一个文件或目录的上下文类型，之后用restorecon即可设置为我们想要的类型。 12345678910111213141516171819202122232425# 1. 先建立 /srv/mycron 同時在內部放入設定檔，同時觀察 SELinux type[root@study ~]# mkdir /srv/mycron[root@study ~]# cp /etc/cron.d/checktime /srv/mycron[root@study ~]# ll -dZ /srv/mycron /srv/mycron/checktimedrwxr-xr-x. root root unconfined_u:object_r:var_t:s0 /srv/mycron-rw-r--r--. root root unconfined_u:object_r:var_t:s0 /srv/mycron/checktime# 2. 觀察一下上層 /srv 的 SELinux type[root@study ~]# semanage fcontext -l | grep &apos;^/srv&apos;SELinux fcontext type Context/srv all files system_u:object_r:var_t:s0# 怪不得 mycron 會是 var_t 囉！# 3. 將 mycron 預設值改為 system_cron_spool_t 囉！[root@study ~]# semanage fcontext -a -t system_cron_spool_t &quot;/srv/mycron(/.*)?&quot;[root@study ~]# semanage fcontext -l | grep &apos;^/srv/mycron&apos;SELinux fcontext type Context/srv/mycron(/.*)? all files system_u:object_r:system_cron_spool_t:s0# 4. 恢復 /srv/mycron 以及子目錄相關的 SELinux type 喔！[root@study ~]# restorecon -Rv /srv/mycron[root@study ~]# ll -dZ /srv/mycron /srv/mycron/*drwxr-xr-x. root root unconfined_u:object_r:system_cron_spool_t:s0 /srv/mycron-rw-r--r--. root root unconfined_u:object_r:system_cron_spool_t:s0 /srv/mycron/checktime# 有了預設值，未來就不會不小心被亂改了！這樣比較妥當些～","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"SELinux","slug":"SELinux","permalink":"http://wyman.wang/tags/SELinux/"}]},{"title":"LVS实验：DR模式","slug":"LVS实验：DR模式","date":"2017-07-06T02:32:57.000Z","updated":"2018-04-26T03:13:15.516Z","comments":true,"path":"2017/07/06/LVS实验：DR模式/","link":"","permalink":"http://wyman.wang/2017/07/06/LVS实验：DR模式/","excerpt":"","text":"NAT模式的相关配置操作请参考《LVS实验之NAT模式的实现》 和NAT模式不同的是，在DR实验中，我们新增一台容器作为Load Balancer，架构变更为： 宿主机环境：充当客户端访问 web 服务； LoadBalancer 的 container：装有 ipvsadm，充当负载均衡调度器； RS1 的 container：部署 Nginx web 服务器，提供 Web 访问服务，充当服务器池中的一员； RS2 的 container：部署 Nginx web 服务器，提供 Web 访问服务，充当服务器池中的一员； 实验步骤一、创建服务器池，并安装必备工具和NAT模式实验一样，所以别来无恙： 安装nginx，vim 修改响应页面 重启nginx服务 1234567docker run --name=RS1 -tdi ubuntudocker run --name=RS2 -tdi ubuntudocker run --name=LB -tid ubuntu...apt-get install vim nginx -y...service nginx start 二、修改web服务器组的内核参数1234567891011121314# 设置只回答目标IP地址是来访网络接口本地地址的ARP查询请求echo \"1\" &gt; /proc/sys/net/ipv4/conf/lo/arp_ignoreecho \"1\" &gt; /proc/sys/net/ipv4/conf/all/arp_ignore# 为了保险自己可以查看一下是否成功修改cat /proc/sys/net/ipv4/conf/lo/arp_ignore# 设置对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.#首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址. #如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送.echo \"2\" &gt; /proc/sys/net/ipv4/conf/lo/arp_announceecho \"2\" &gt; /proc/sys/net/ipv4/conf/all/arp_announce# 使得上面的配置立即生效sysctl -p ARP 的内核参数详解：arp_ignore 部分参数：定义了本机响应 ARP 请求的级别0表示目标 IP 是本机的，则响应 ARP 请求。默认为 0；1如果接收 ARP 请求的网卡 IP 和目标 IP 相同，则响应 ARP 请求； arp_announce 参数：定义了发送 ARP 请求时，源 IP 应该填什么。0 表示使用任一网络接口上配置的本地 IP 地址，通常就是待发送的 IP 数据包的源 IP 地址 。默认为 01 尽量避免使用不属于该网络接口(即发送数据包的网络接口)子网的本地地址作为 ARP 请求的源 IP 地址。大致的意思是如果主机包含多个子网，而 IP 数据包的源 IP 地址属于其中一个子网，虽然该 IP 地址不属于本网口的子网，但是也可以作为ARP 请求数据包的发送方 IP。2 表示忽略 IP 数据包的源 IP 地址，总是选择网络接口所配置的最合适的 IP 地址作为 ARP 请求数据包的源 IP 地址(一般适用于一个网口配置了多个 IP 地址) 三、配置web服务器网卡别名只有目的 IP 是本机器中的一员时才会做相映的处理，所以需要添加网卡别名1ifconfig lo:0 192.168.0.10 broadcast 192.168.0.10 netmask 255.255.255.255 up 两台nginx服务器需做同样的设置 四、设置LoadBalancer调度规则在Load Balancer容器中，设置相应的ipvsadm规则：1234ipvsadm -A -t 192.168.0.10:80 -s rr # 定义集群服务ipvsadm -a -t 192.168.0.10:80 -r 192.168.0.3 -g # 添加 RS1ipvsadm -a -t 192.168.0.10:80 -r 192.168.0.4 -g # 添加 RS2ipvsadm -l 参数：-A：添加一个新的集群服务-t: 使用 TCP 协议-s: 指定负载均衡调度算法rr：轮询算法(LVS 实现了 8 中调度算法)192.168.0.10:80 定义集群服务的 IP 地址（VIP） 和端口 -a：添加一个新的 RealServer 规则-t：tcp 协议-r：指定 RealServer IP 地址-g：定义为 DR 模式上面命令添加了两个集群服务器 RealServer1 和 RealServer2 五、设置Load Balancer网卡别名ifconfig eth0:0 192.168.0.10 netmask 255.255.255.0 up 六、完成配置，测试验证和NAT模式一样，按住F5不断刷新，看页面是否变化，验证LVS是否正常工作","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"LVS","slug":"LVS","permalink":"http://wyman.wang/tags/LVS/"},{"name":"ipvsadm","slug":"ipvsadm","permalink":"http://wyman.wang/tags/ipvsadm/"},{"name":"docker","slug":"docker","permalink":"http://wyman.wang/tags/docker/"}]},{"title":"LVS实验：NAT模式","slug":"LVS实验：NAT模式","date":"2017-07-05T10:17:10.000Z","updated":"2018-04-26T03:13:15.521Z","comments":true,"path":"2017/07/05/LVS实验：NAT模式/","link":"","permalink":"http://wyman.wang/2017/07/05/LVS实验：NAT模式/","excerpt":"","text":"实验利用用两台docker容器完成web请求响应，使用nginx来验证LVS功能 实验的LVS集群按功能模块分为： Load Balancer + RealServer 两个模块 其中： Load Balancer由宿主机实现，位于集群系统的前端，通过ipvsadm实现对后端服务器实现负载均衡功能，对外 IP 地址也成为 VIP（虚拟 IP 地址） Real Server分别由两台安装了nginx的容器代替，完成web请求响应，服务器分别命名为RS1、RS2 实验步骤一、安装 ipvsadm 工具实验环境在ubuntu下进行，使用apt-get完成ipvsadm的安装 1234sudo apt-get install ipvsadm -y# 使用 ipvsadmsudo ipvsadm -L 二、创建Real Server池1、使用docker创建两台容器12docker run --name=RS1 -tdi ubuntudocker run --name=RS2 -tdi ubuntu 2、登录两台容器，记录各自的IP123docker exec RS1 -it /bin/bash...ifconfig RS1：IP 地址为 192.168.0.2 RS2：IP 地址为 192.168.0.3 3、安装工具1apt-get install vim nginx -y 4、为区别两台容器所响应，分别修改各自的响应页面1vi /usr/share/nginx/html/index.html PS: 改好后记得重启nginx服务 在宿主机上使用浏览器验证两台容器的web服务是否正常工作： 三、修改调度规则1、Load Balancer为宿主机，修改宿主机上的内核路由转发：1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 2、使用 ipvsadm 添加 ipvs 规则，并定义集群服务1234sudo ipvsadm -A -t LB本机IP:80 -s rr #定义集群服务sudo ipvsadm -a -t LB本机IP:80 -r 192.168.0.2 -m #添加 RealServer1sudo ipvsadm -a -t LB本机IP:80 -r 192.168.0.3 -m #添加 RealServer2sudo ipvsadm -l #查看 ipvs 定义的规则 添加集群服务参数详解：-A：添加一个新的集群服务-t: 使用 TCP 协议-s: 指定负载均衡调度算法rr：轮询算法(LVS 实现了 8 中调度算法)LB本机IP:80 定义集群服务的 IP 地址（VIP） 和应用端口 -a：添加一个新的 RealServer 规则-t：tcp 协议-r：指定 RealServer IP 地址-m：定义为 NAT上面命令添加了两个服务器 RS1 和 RS2 四、配置完成，测试验证使用浏览器打开本机IP，按住F5作死地刷新，看到页面不一致则说明LVS起作用了","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"LVS","slug":"LVS","permalink":"http://wyman.wang/tags/LVS/"},{"name":"ipvsadm","slug":"ipvsadm","permalink":"http://wyman.wang/tags/ipvsadm/"},{"name":"docker","slug":"docker","permalink":"http://wyman.wang/tags/docker/"}]},{"title":"LVS概要","slug":"LVS概要","date":"2017-06-27T03:49:06.000Z","updated":"2018-04-26T03:13:15.540Z","comments":true,"path":"2017/06/27/LVS概要/","link":"","permalink":"http://wyman.wang/2017/06/27/LVS概要/","excerpt":"","text":"LVS 的组成 由于 LVS 只是对 IP 进行处理，对数据包的内容并不关心，所以称为基于 IP 的负载均衡技术。 三个层次： 负载调度器层（load balancer）：它是整个集群对外面的前端机，负责将客户端的请求发送到一组后端服务器上执行，负载调度层通常由一台或者多台负载调度器(Director Server)组成，LVS 模块需要安装在每个负载调度器上。 服务器池层（Server pool）：是一组真正处理客户请求的服务器，执行的服务为 WEB、MAIL、FTP 和 DNS 等。每个真实服务器(Real Server)之前通过高速的 LAN 或分布在各地的 WAL 相连接。 数据共享储存层(Share Storage)：它为服务器池提供一个共享的存储区，这样容易使得服务器池中的主机拥有相同的信息与配置，从而便于共同提供服务。 LVS的实现IP 负载均衡技术分为三种： 通过 NAT 实现虚拟服务器（VS/NAT） 通过 IP 隧道实现虚拟服务器（VS/TUN） 通过直接路由实现虚拟服务器（VS/DR） 1、通过 NAT 实现虚拟服务器（VS/NAT）主要工作流程： 当用户通过虚拟 IP 地址（VIP，可通过公网访问）访问网络服务时，请求到达调度器，调度器将根据调度算法动态的从后端服务器池中选取一台真实服务器（Real Server）负责响应，同时调度器将请求报文的目标地址（VIP）改写为 Real Server 的 IP 地址，将报文的目标端口改写为 Real Server 相应的端口，最后将报文发送给选定的 Real Server，同时调度器在连接 Hash 表中记录这个连接记录。 Real Server 收到数据并处理数据后，将响应的报文发送给调度器，调度器根据连接 Hash 表中的记录，将响应报文的源 IP 地址和源端口改写为虚拟IP（VIP）和调度器的相应端口。 最后，调度器将响应数据发送给用户，完成这个负载均衡过程。 在 NAT 模式下，用户请求和响应报文都会经过负载调度器，并且被修改 IP 地址和端口。整个过程中，用户只能看到是 VIP 所在服务器提供的服务，而后端服务器集群结构对用户是透明的。 缺点所有进出的报文都要经过负载均衡器（Director Server），当用户请求很多时，调度器的处理能力将会成为整个系统的瓶颈。一般支持的真实服务器数目在 10 台至 20 台左右。 2、通过直接路由实现虚拟服务器（VS/DR）VS/DR（Virtual Server via Direct Routing）利用大多数 Internet 服务的非对称特点，负载调度器中只负责调度请求，而服务器直接将响应返回给客户，可以极大地提高整个集群系统的吞吐量： 1、客户端通过 Internet 向服务器发起请求，而请求的 IP 地址指向的是调度器上对外公布的 IP 地址； 2、请求报文到达调度器（Load Balancer），调度器根据各个服务器的负载情况，动态地选择一台服务器，不修改也不封装 IP 报文，而是将数据帧的 MAC 地址改为选出服务器的 MAC 地址，再将修改后 的数据帧在与服务器组的局域网上发送。因为数据帧的 MAC 地址是选出的服务器，所以服务器肯定可以收到这个数据帧； 3、Real Server 接收到报文之后，发现报文的目标地址 VIP 是在本地的网络设备上，服务器处理这个报文，然后根据路由表将响应报文直接返回给客户。 特点： 集群节点，也就是 Real Server 与 Load Balacer 必须在同一个物理网络中； RIP 通常是私有地址，也可以是公网地址，以便于远程管理与监控； Load Balancer 仅仅负责处理入站的请求，Real Server 将直接响应客户端； 不支持端口映射：也就是Real Server 的端口必须是与 Load Balancer 对外服务的一样； 3、通过 IP 隧道实现虚拟服务器（VS/TUN）IP隧道（IP tunneling）是将一个 IP 报文封装在另一个 IP 报文的技术，这可以使得目标为一个 IP 地址的数据报文能被封装和转发到另一个 IP 地址。IP 隧道技术亦称为 IP 封装技术（IP encapsulation）。IP 隧道主要用于移动主机和虚拟私有网络（Virtual Private Network），在其中隧道都是静态建立的，隧道一端有一个 IP 地址，另一端也有唯一的 IP 地址。","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"LVS","slug":"LVS","permalink":"http://wyman.wang/tags/LVS/"}]},{"title":"LDAP的一些操作精髓","slug":"LDAP操作精华","date":"2017-04-06T12:06:09.000Z","updated":"2018-04-26T03:13:15.515Z","comments":true,"path":"2017/04/06/LDAP操作精华/","link":"","permalink":"http://wyman.wang/2017/04/06/LDAP操作精华/","excerpt":"","text":"最近在做LDAP大整改，实现LDAP用户通过ssh访问服务器，总结一下LDAP配置中常见的一些操作 1、客户端的操作需要安装的包： nss-pam-ldapd pam_ldap 配置文件的修改：（将原pam_sss认证改为ldap认证） vi /etc/pam.d/system-auth vi /etc/pam.d/password-auth 123456789101112131415161718192021222324252627auth required pam_env.soauth sufficient pam_fprintd.soauth sufficient pam_unix.so nullok try_first_passauth requisite pam_succeed_if.so uid &gt;= 500 quietauth sufficient pam_ldap.soauth required pam_deny.soaccount required pam_unix.soaccount sufficient pam_localuser.soaccount sufficient pam_succeed_if.so uid &lt; 500 quietaccount [default=bad success=ok user_unknown=ignore] pam_ldap.soaccount required pam_permit.sopassword requisite pam_cracklib.so try_first_pass retry=3 type=password sufficient pam_unix.so md5 shadow nullok try_first_pass use_authtokpassword sufficient pam_ldap.so use_authtokpassword required pam_deny.sosession optional pam_keyinit.so revokesession required pam_limits.sosession [success=ok default=ignore] pam_succeed_if.so service in crond quiet use_uidsession required pam_unix.sosession required pam_mkhomedir.so skel=/etc/skel/ umask=0022session optional pam_ldap.so 2、服务器端的操作1）修改密码 12ldappasswd -x -D &quot;cn=Manager,dc=domain,dc=com&quot; &quot;uid=username,dc=domain,dc=com&quot; -s $passwd# 以用户在LDAP中的dn为标识“uid=username,dc=domain,dc=com” 2)删除操作 删除时，给出dn即可：12ldapdelete -x -D &apos;cn=Manager,dc=domain,dc=com&apos; -w yourpasswd -r &apos;dc=domain,dc=com&apos;-r 表示以递归模式删除，即删除该节点下面的所有子节点。","categories":[{"name":"LinuxOPS","slug":"LinuxOPS","permalink":"http://wyman.wang/categories/LinuxOPS/"}],"tags":[{"name":"LDAP","slug":"LDAP","permalink":"http://wyman.wang/tags/LDAP/"}]},{"title":"LDAP的配置","slug":"ldap的配置（完整版）","date":"2017-04-02T02:02:38.000Z","updated":"2018-04-26T03:13:15.543Z","comments":true,"path":"2017/04/02/ldap的配置（完整版）/","link":"","permalink":"http://wyman.wang/2017/04/02/ldap的配置（完整版）/","excerpt":"","text":"转载李先生的文章： 《完整版的OpenLDAP搭建全过程》 Wiil的文章 Centos6.5搭建LDAP服务器及用户添加删除 远离尘世之方舟的两篇博文： ### (2018年2月更新) 《RHEL7-openldap安装配置一（服务器端安装配置）》 《RHEL7-openldap安装配置二（客户端安装配置）》 按文章一步步实施，验证可用，特此转载并记录","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"LDAP","slug":"LDAP","permalink":"http://wyman.wang/tags/LDAP/"}]},{"title":"docker中的一些技巧命令","slug":"docker中的一些技巧命令","date":"2017-02-19T10:26:54.000Z","updated":"2018-04-26T03:13:15.542Z","comments":true,"path":"2017/02/19/docker中的一些技巧命令/","link":"","permalink":"http://wyman.wang/2017/02/19/docker中的一些技巧命令/","excerpt":"","text":"获取日志 获取容器的输出信息可以使用如下命令： docker logs [OPTIONS] CONTAINER 常用的配置项有： -t 或 –timestamps 显示时间戳 -f 实时输出，类似于 tail -f 如下所示，我们查看刚刚创建的容器的日志，使用如下命令： $ docker container logs -tf test 显示进程 除了获取日志之外，还可以显示运行中的容器的进程信息，例如查看刚刚创建的容器的进程信息： $ docker container top test 需要注意的是，该命令对于并未运行的容器是无效的 查看修改 查看相对于镜像的文件系统来说，容器中做了哪些改变，可以使用如下命令： docker container diff test 例如我们在 test 容器中创建一个文件123,然后删除了一个文件2，就可以使用 diff 命令查看到相应的修改： 12345$ docker diff test [18:33:52]C /rootA /root/.bash_historyA /root/123A /root/2 它只记录了上一回的修改操作 最后，附上docker run 的一些常用参数，参考lynk-coder的博文《4.1 docker-1.12 run命令运行以及参数详解》1234567891011121314151617181920212223242526272829303132333435363738394041Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] -d, --detach=false 指定容器运行于前台还是后台，默认为false -i, --interactive=false 打开STDIN，用于控制台交互 -t, --tty=false 分配tty设备，该可以支持终端登录，默认为false -u, --user=\"\" 指定容器的用户 -a, --attach=[] 登录容器（必须是以docker run -d启动的容器） -w, --workdir=\"\" 指定容器的工作目录 -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 -e, --env=[] 指定环境变量，容器中可以使用该环境变量 -m, --memory=\"\" 指定容器的内存上限 -P, --publish-all=false 指定容器暴露的端口 -p, --publish=[] 指定容器暴露的端口 -h, --hostname=\"\" 指定容器的主机名 -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities --cidfile=\"\" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 --cpuset=\"\" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU --device=[] 添加主机设备给容器，相当于设备直通 --dns=[] 指定容器的dns服务器 --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 --entrypoint=\"\" 覆盖image的入口点 --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 --name=\"\" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 --net=\"bridge\" 容器网络设置: bridge 使用docker daemon指定的网桥 host //容器使用主机的网络 container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 none 容器使用自己的网络（类似--net=bridge），但是不进行配置 --privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities --restart=\"no\" 指定容器停止后的重启策略: no：容器退出时不重启 on-failure：容器故障退出（返回值非零）时重启 always：容器退出时总是重启 --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理","categories":[{"name":"docker","slug":"docker","permalink":"http://wyman.wang/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://wyman.wang/tags/docker/"}]},{"title":"Dockerfile 基本格式","slug":"Dockerfile-基本格式","date":"2016-11-21T10:54:19.000Z","updated":"2018-04-26T03:13:15.515Z","comments":true,"path":"2016/11/21/Dockerfile-基本格式/","link":"","permalink":"http://wyman.wang/2016/11/21/Dockerfile-基本格式/","excerpt":"","text":"参考官方文档对于一个 Dockerfile 文件内容来说，基本语法格式如下所示： INSTRUCTION arguments 使用 # 号作为注释，指令（INSTRUCTION）不区分大小写，但是为了可读性，一般将其大写。而 Dockerfile 的指令一般包含下面几个部分： 基础镜像：以哪个镜像为基础进行制作，使用 FROM 指令来指定基础镜像，一个 Dockerfile 必须以 FROM 指令启动。 维护者信息：可以指定该 Dockerfile 编写人的姓名及邮箱，使用 MAINTAINER 指令。 镜像操作命令：对基础镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是 RUN 命令。 容器启动命令：基于该镜像的容器启动时需要执行哪些命令，常见的是 CMD 命令或 ENTRYPOINT 举个栗子： 1234567891011# 指定基础镜像FROM ubuntu:14.04# 维护者信息MAINTAINER shiyanlou/shiyanlou001@simplecloud.cn# 镜像操作命令RUN apt-get -yqq update &amp;&amp; apt-get install -yqq apache2# 容器启动命令CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;] 通过阅读上述内容可以很容易的创建一个 apache 的镜像。包含了最基本的四项信息。 其中 FROM 指定基础镜像。 RUN 命令默认使用 /bin/sh，并使用 root 权限执行。 CMD 命令也是默认在 /bin/sh 中执行，但是只能有一条 CMD 指令，如果有多条则只有最后一条会被执行。 下面我们创建一个空目录，并在其中编辑 Dockerfile 文件，并基于此构建一个新的镜像，使用如下操作： 12345678# 首先创建目录并切换目录$ mkdir /home/wyman/test &amp;&amp; cd /home/wyman/test# 编辑 Dockerfile 文件，默认文件名为 `Dockerfile`，也可以使用其它值，使用其它值需要在构建时通过 `-f` 参数指定，这里我们使用默认值。并在其中添加上述示例的内容$ vim Dockerfile# 使用 build 命令，`-t` 参数指定新的镜像,注意语法，后面有个“.”，表示在此文件夹中创建容器$ docker image build -t wyman_test:1.0 . 1234567891011...$ docker image build -t wyman:1.0 . [19:06:13]Sending build context to Docker daemon 3.072kBStep 1/4 : FROM ubuntu:14.0414.04: Pulling from library/ubuntu99ad4e3ced4d: Downloading 32.33MB/73MBec5a723f4e2a: Download complete 2a175e11567c: Download complete 8d26426e95e0: Download complete 46e451596b7c: Download complete... 构建过程比较慢，在构建完成后，我们可以使用该镜像启动一个容器来运行 apache 服务，运行如下命令： 12 # 使用 -p 参数将本机的 8000 端口映射到容器中的 80 端口上。$ docker container run -d -p 8000:80 --name wyman_docker wyman:1.0 容器启动成功后，并且配置了端口映射，我们就可以通过本机的 8000 端口访问容器 wyman_docker 中的 apache 服务了。我们打开浏览器，输入 localhost:8000 即可看到熟悉的apache问候界面了","categories":[{"name":"Docker","slug":"Docker","permalink":"http://wyman.wang/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://wyman.wang/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://wyman.wang/tags/Dockerfile/"}]},{"title":"基于RHCS+iSCSI+cLVM+GFS2的共享存储系统","slug":"基于RHCS-iSCSI-cLVM-GFS2的共享存储系统","date":"2016-01-12T02:02:13.000Z","updated":"2018-04-26T03:13:15.875Z","comments":true,"path":"2016/01/12/基于RHCS-iSCSI-cLVM-GFS2的共享存储系统/","link":"","permalink":"http://wyman.wang/2016/01/12/基于RHCS-iSCSI-cLVM-GFS2的共享存储系统/","excerpt":"","text":"共享存储是集群的重要组成部分之一，iSCSI使用TCP/IP网络协议完成原本需要FC光纤通道完成的功能，利用网络实现磁盘等块级存储设备在网络上的存储 iSCSI的 组成一个简单的iSCSI系统主要分以下两部分： iSCSI target iSCSI Initiator （当然还有交换机、HBA卡之类的其他部分） iSCSI target iSCSI target 可以理解为用于存储数据的磁盘阵列或具有iSCSI功能的其他存储设备，大多数操作系统都可以通过软件将系统变为一个iSCSI target，将iSCSI target软件安装在PC服务器上，即可实现将PC转变为一台具有iSCSI功能的存储服务器。 iSCSI Initiator iSCSI Initiator是iSCSI的驱动程序，通过安装initiator可以实现iSCSI服务器与iSCSI存储设备的连接，当然，也可以使用HBA卡来完成这项功能。 所以，使用PC服务器来部署一套完整的iSCSI系统，需要安装iSCIS target 与 iSCSI initiator 前奏 环境 节点 系统 IP node1 RHEL6.8 192.168.200.1 node2 RHEL6.8 192.168.200.2 node3 RHEL6.8 192.168.200.3 EPR RHEL6.8 192.168.200.253 完成节点间SSH无密码访问 环境如上，完成后可以开始正式的部署工作 一、部署RHCS系统 iSCSI共享存储在多用户同时读写的过程中会出现互斥和无法同步的问题，因为是块级别的共享，这个问题无法通过SCSI设备自身解决，需要依赖集群文件系统所提供的锁管理机制（比如RHCS中的DLM）来解决读写互斥和同步的问题，这里使用RHCS套件所提供的GFS文件系统，这也是为啥第一步要先搭建RHCS环境的原因 1、安装RHCS集群套件 各节点（node1-node3）需要安装的套件包： cman rgmanager ricci gfs2 lvm2 RHCS集群套件在系统光盘上自带，使用yum即可直接进行安装： yum install -y cman* gfs2* rgmanager* ricci* lvm2* 其实安装了rgmanager就自动安装好了cman、ricci 启动上述安装的各类服务： service cman start service rgmanager start service ricci start 在管理节点上（EPR:192.168.200.253）安装RHCS集群管理界面luci: yum install luci* -y 2、通过luci配置集群 启动Luci服务后即可使用浏览器登录https://EPR:8084完成集群的配置与管理 https://EPR:8084可以输入本机的root账户密码进行登录 在“ManagerCluster”中选择“Create”创建一个集群 经过简单的账号密码节点名的输入配置后,集群成功创建并启动： 坑1：在各节点上创建ricci用户，并创建密码，可避免出现ricci启动失败的情况； 坑2：cman启动失败,将失败节点中的NetworkManage服务关闭后解决; 坑3：关闭防火墙！ 稍等一会，等圈圈转完之后，集群创建成功： 二、iSCSI配置 之前说到，一个iSCSI系统包含target端和initiator端，这里将作为iSCSI设备的EPR服务器（192.168.200.253）作为存储设备，给它安装target软件包：scsi-target-utils；将node1-node3作为initiator端，安装iscsi-initiator-utils软件包；同样，两个软件包都可以直接yum install 1、target端配置(192.168.200.253)： 1）启动target后台服务进程tgtd：1service tgtd start 2）创建target1tgtadm -L iscsi --op new --mode target --tid 1 -T iqn.2018-03.com:home 说明:–op:做什么操作，new,delete,show等；–mode:针对哪个对象，有session,node,discovery等；–tid：定义target的ID；-T 指定创建的target叫啥；-T参数后接的一串为target在全网中的名称，必须唯一； 3）创建LUN tgtadm -L iscsi –op new –mode logicalunit –tid 1 –lun 1 -b /dev/sdb 说明：–mode logicalunit：嗯，LUN嘛–lun:指定lun的标识ID，此处为1-b: 指定划分lun的分区 4）配置访问权限 tgtadm -L iscsi –op bind –mode target –tid 1 -I 192.168.200.0/24 说明：此处只打开192.168.200.0网段的访问权限，3260端口开启监听；可以通过–user参数加–password参数创建访问用户的权限 5）查看划分结果 tgtadm -L iscsi –op show -m target 说明：lun0 默认被target驱动器所占用，所有的lun编号从1开始。lun1已经成功创建，由/dev/sdb分区提供空间，所有在192.168.200.0网段中的initiator都可共享访问；Tips:删除target1中的lun1：tgtadm -L iscsi –op delete –mode logicalunit –tid 1 –lun 1删除target1的操作：tgtadm -L iscsi –op delete –mode target –tid 1 2、initiator端配置(node1-node3) 首先，各节点启动iscsi服务：service iscsi start 1）开启target发现 iscsiadm -m disvovery -m sendtargets -p 192.168.200.253:3260 监听后如果发现网段中存在可访问的target则返回成功的消息：tips: 成功执行一次target发现后，initiator节点会在/var/lib/iscsi/send_targets目录下生成相关的target信息，下次服务启动会自动连接该target坑：执行target发现后，节点重启，再启动iscsi服务失败，尝试着删除/var/lib/iscsi/send_targets所有目录，再启动依旧失败，后来重新执行了一次target发现后，iscsi服务启动成功 2）连接所发现的target iscsiadm -m node -T iqn.2018-03.com:home -p 192.168.200.253 -l 或者： iscsiadm -m node –loginall=all #连接所发现的所有target tips:查询已连接的target信息：iscsiadm -m session -s断开已连接的target：iscsiadm -m node -T iqn.2018-03.com:home -p 192.168.200.253 -u 3）查看是否成功连接共享存储 执行fdisk -l，可以发现所有节点都新增了一块磁盘，说明之前的发现操作和连接操作都已成功，共享存储出现在了各个节点上 当然，我们也可以在target上查看已连接该target的所有initiator： tgt-admin –show 到这，iSCSI的配置就完成了 三、GFS配置GFS与CLVM都是RHCS的组件，GFS提供集群文件系统，CLVM完成集群逻辑卷的管理功能，使得集群中的机器可以用LVM管理共享存储，所以，在创建GFS之前，必须先完成CLVM的部署。 1、CLVM的配置 前面已经在各节点安装了clvm，在启动clvm之前，先将clvm中的锁机制设置为集群模式 可以直接修改/etc/lvm/lvm.conf文件中的“locking_type”值改为“3”，也可以直接通过命令完成 lvmconf --enable-cluster 完成修改后，启动clvm服务： service clvmd start 当然，所有集群节点都得启动 2、创建逻辑卷 在完成了iSCSI的配置后，我们在各节点上都发现多了一块2T的本地磁盘，该磁盘即为192.168.200.253作为target的形式所共享出来的磁盘，所有节点通过initiator发现和连接操作，将共享磁盘映射为本地/dev/sdb分区，我们将该共享磁盘以vg的形式分出去，创建lv再挂载至节点上工集群使用，而集群中的任一节点对该共享磁盘进行的LVM操作都会同步到其它节点，所以以下的操作在任一集群节点上完成即可. 1234pvcreate /dev/sdbvgcreate vg_cluster /dev/sdblvcreate -L 2T -n lv_cluster_home... 如果没出什么意外，我们成功创建了一个名为vg_cluster的卷组，在这个卷组中只有1个逻辑卷，名称为lv_cluster_home,大小为2T 各种查看命令走一波：123vgspvslvs 确认都OK 3、创建GFS文件系统 接下来将逻辑卷格式化为gfs2文件系统，gfs2文件系统具有锁机制，允许多个节点对同一个磁盘分区同时读写 1mkfs.gfs2 -p lock_dlm -j 6 -t clustername:my_gfs /dev/vg_cluster/lv_cluster_home 说明：-p lock_dlm :设置DLM锁方式，如果没有此参数，当两个或以上的系统同时挂载此分区是就会想ext3格式一样，两个系统的信息不能同步-t clustername:my_gfs ：指定DLM锁所在的表的名称，clustername就是第一步中所创建的RHCS集群名称，必须和/etc/cluster/cluster.conf中的Cluster标签上的name一致-j 6 ：设置了6个日志系统，也就是说允许最多6个节点同时挂载tips: 增加日志数量 gfs2_jadd -j 8 /dev/vg_cluster/lv_cluster_home查看可挂载的节点数 gfs2_tool journals /dev/vg_cluster/lv_cluster_home 在弹出的对话框中，选择y，没有意外的话，文件系统格式化成功 验证一下 在node1上将/dev/vg_cluster/lv_cluster_home挂载到/home下面，新建一个名为1的文件： mount -t gfs2 /dev/vg_cluster/lv_cluster_home /home touch 1 在node2上也将/dev/vg_cluster/lv_cluster_home挂载到/home下面，ls一下，发现1文件存在 在node1上的1文件上写点东西，看看node2上能否立刻同步 echo &quot;hello gfs2 to every nodes&quot; &gt; 1 在node2上查看一下1文件 OK,node2上也有了 好了，基于RHCS+iSCSI+cLVM+GFS2的共享存储已经正常运行了","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"RHCS","slug":"RHCS","permalink":"http://wyman.wang/tags/RHCS/"},{"name":"iSCSI","slug":"iSCSI","permalink":"http://wyman.wang/tags/iSCSI/"},{"name":"CLVM","slug":"CLVM","permalink":"http://wyman.wang/tags/CLVM/"},{"name":"GFS2","slug":"GFS2","permalink":"http://wyman.wang/tags/GFS2/"},{"name":"集群","slug":"集群","permalink":"http://wyman.wang/tags/集群/"},{"name":"存储","slug":"存储","permalink":"http://wyman.wang/tags/存储/"}]},{"title":"Linux ip_forward的相关知识点","slug":"Linux-ip-forward的相关概念","date":"2015-12-09T06:54:09.000Z","updated":"2018-04-26T03:13:15.541Z","comments":true,"path":"2015/12/09/Linux-ip-forward的相关概念/","link":"","permalink":"http://wyman.wang/2015/12/09/Linux-ip-forward的相关概念/","excerpt":"","text":"简介IP地址分为公有ip地址和私有ip地址，公有ip地址是由INIC(internet network information center)负责的，这些IP地址分配给了注册并向INIC提出申请的组织机构。私有ip地址属于非注册地址，专门为组织内部使用。私有ip地址是不可能直接用来跟WAN通信的，要么利用帧来通信（FRE帧中继，HDLC,PPP）,要么需要路由的转发(nat)功能把私有地址转换为公有地址才行。 数据转发原理 首先内网主机向外网主机发送数据包，由于内网主机与外网主机不在同一网段，所以数据包暂时发往内网默认网关GIP处理，而本网段的主机对此数据包不做任何回应。由于内网主机的SIP是私有的，禁止在公网使用，所以必须将数据包的SIP修改成公网上的可用IP，这就是网关收到数据包之后首先要做的事情–IP地址转换 然后网关再把数据包发往外网主机。外网主机收到数据包之后，只认为这是网关发送的请求，并不知道内网主机的存在，更不知道源IP地址是SIP而不是FIP，也没必要知道，目的主机处理完请求，把回应信息发还给网关的FIP。网关收到后，将目的主机返回的数据包的目标IP即FIP修改为发出请求的内网主机的IP地址即SIP，并根据路由表将其发给内网主机。这就是网关的第二个工作–数据包的路由转发。内网主机只要查看数据包的DIP与发送请求的SIP相同，就会回应，这就完成了一次请求。 出于安全考虑，Linux系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。 配置Linux下的IP转发功能 CentOS6: 方法1：1[root@centos6 ~]# echo 1 &gt; /proc/sys/net/ipv4/ip_forward 注意：这种方式重启网络服务或主机后失效 若要其自动执行，可将命令echo “1” &gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local 或者 在/etc/sysconfig/network脚本中添加 FORWARD_IPV4=”YES” 方法2：123vim /etc/sysctl.conf...net.ipv4.ip_forward = 0 #添加一行 CentOS7:12345678[root@CentOS7 ~]# vim /etc/sysctl.d/99-sysctl.conf ... 结尾添加： net.ipv4.ip_forward = 1:wq[root@CentOS7 ~]# sysctl -pnet.ipv4.ip_forward = 1 //查看修改结果.[root@CentOS7 ~]#","categories":[],"tags":[{"name":"ip_forward","slug":"ip-forward","permalink":"http://wyman.wang/tags/ip-forward/"}]},{"title":"故障：解决network proxy对话框问题","slug":"故障：解决network-proxy对话框问题","date":"2015-07-13T02:06:04.000Z","updated":"2018-04-26T03:13:15.888Z","comments":true,"path":"2015/07/13/故障：解决network-proxy对话框问题/","link":"","permalink":"http://wyman.wang/2015/07/13/故障：解决network-proxy对话框问题/","excerpt":"","text":"编辑文件: /etc/xdg/autostart/gpk-update-icon.desktop 在底部加入: X-GNOME-Autostart-enabled=false","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[]},{"title":"故障：nfs挂载出现nobody","slug":"故障：nfs挂载出现nobody","date":"2015-06-09T10:55:56.000Z","updated":"2018-04-26T03:13:15.887Z","comments":true,"path":"2015/06/09/故障：nfs挂载出现nobody/","link":"","permalink":"http://wyman.wang/2015/06/09/故障：nfs挂载出现nobody/","excerpt":"","text":"在客户端清除idmap的缓存，然后重启rpcidmap，并重新挂载。大部分情况下可以解决1234[root@ha1 ~]# nfsidmap -c[root@ha1 ~]# /etc/init.d/rpcidmapd restart正在启动 RPC idmapd： [确定]正在启动 RPC idmapd： [确定] 如果上面的办法没有解决，可以用下面的办法nfs服务器端，修改/etc/idmapd.conf，给Domain指定一个值，然后重启rpcidmap服务。 1234567[root@ha2 ~]# vi /etc/idmapd.conf[General]#Verbosity = 0# The following should be set to the local NFSv4 domain name# The default is the host&apos;s DNS domain name.#Domain = local.domain.eduDomain = mydomain.com 重启服务 123[root@ha2 ~]# /etc/init.d/rpcidmapd restartShutting down RPC idmapd: [确定]正在启动 RPC idmapd： [确定] nfs客户端，同样修改/etc/idmapd.conf，给Domain指定一个值，要与服务器端指定的域名相同，然后重启rpcidmap服务 1234567[root@ha1 ~]# vi /etc/idmapd.conf[General]#Verbosity = 0# The following should be set to the local NFSv4 domain name# The default is the host&apos;s DNS domain name.#Domain = local.domain.eduDomain = mydomain.com 重启服务 1234[root@ha1 ~]# /etc/init.d/rpcidmapd restart正在启动 RPC idmapd： [确定]正在启动 RPC idmapd： [确定] 重新挂载后，发现目录属主正常，为www 123456789101112[root@ha1 ~]# df -h文件系统 容量 已用 可用 已用%% 挂载点/dev/sda2 9.9G 2.3G 7.1G 25% /tmpfs 244M 0 244M 0% /dev/shm/dev/sda1 194M 28M 157M 15% /boot/dev/sda5 8.7G 148M 8.1G 2% /data192.168.1.109:/data/nfsshare 19G 1.2G 17G 7% /mnt[root@ha1 ~]# ll /mnt/总用量 0-rw-rw-r-- 1 www www 0 3月 25 14:15 a-rw-rw-r-- 1 www www 0 3月 25 15:32 bb","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"nfs","slug":"nfs","permalink":"http://wyman.wang/tags/nfs/"}]},{"title":"故障：resize2fs 报错","slug":"故障：resize2fs-报错","date":"2015-05-29T07:00:42.000Z","updated":"2018-04-26T03:13:15.888Z","comments":true,"path":"2015/05/29/故障：resize2fs-报错/","link":"","permalink":"http://wyman.wang/2015/05/29/故障：resize2fs-报错/","excerpt":"","text":"对LVM进行扩容的最后，用resize2fs对相关卷生效的时候，报错信息： Bad magic number in super-block while trying to open xxxxCouldn’t find valid file system superblock 原因：系统使用不是ext3文件系统 解决办法： 查看当前系统下的该卷用的是什么文件系统 cat /etc/fstab 发现服务器中/dev/mapper/VolGroup00/disk1所用的是reiserfs 用命令resize_reiserfs / dev/mapper/VolGroup00/disk1即可解决","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[]},{"title":"在线调整LV卷的大小","slug":"在线调整LV卷的大小","date":"2015-04-11T09:05:48.000Z","updated":"2018-04-26T03:13:15.874Z","comments":true,"path":"2015/04/11/在线调整LV卷的大小/","link":"","permalink":"http://wyman.wang/2015/04/11/在线调整LV卷的大小/","excerpt":"","text":"/tmp目录不知道是哪个挨千刀的设置的，容量太小，时不时就满； 服务器磁盘无法立即扩容，但幸好其他卷的剩余空间足够大，于是，我们想着从隔壁卷(/backup)抽调一些空间出来，分配给/tmp所在LV卷 大致分为两个环节： 一、缩减其他LV卷的空间1、卸载需要缩减空间的LV卷所挂载的文件系统首先，df -kh 查看一下磁盘使用情况123456789Filesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup-LogVol00 40G 26G 12G 70% / .../dev/sda1 485M 37M 423M 8% /boot/dev/mapper/VolGroup-LogVol03 3G 2.9G 120M 99% /home/dev/mapper/VolGroup-backup 200G 100G 100G 50% /backup 将VolGroup-backup卷从文件系统上umount掉1umount /backup 2、缩减VolGroup-backup所在的文件系统大小这一步很重要，如果没有进行文件系统的缩减而直接对LV卷进行操作，会破坏原有的数据 我们的需求是将卷VolGroup-backup的空间挤压出几个G来，于是：1resize2fs /dev/mapper/VolGroup-backup 190G (将VolGroup-backup缩减至190G，腾出大约10个G的空间) 3、缩减VolGroup-backup的LV卷1lvreduce -L -3G /dev/mapper/VolGroup-backup (注意区别：-3G—容量缩减3G；3G—容量调整成3G) 我们可以通过lvs或者vgs查看一下LV卷的整体情况 在vgdislay中可以看到Free PE字段显示剩余空间已经有了几个G OK，至此已经完成第一个环节：缩减空间 二、增加目标卷的空间1、扩展卷 VolGroup-backup1lvextend -L 3G /dev/mapper/VolGroup-backup 2、增加VolGroup-backup文件系统空间1resize2fs /dev/mapper/VolGroup-backup 别忘了把/dev/mapper/VolGroup-backup重新挂载到原目录下/backup12mount /dev/mapper/VolGroup-backup /backupdf -kh # 可以查看一下是否成功 至此，/tmp目录容量大小调整完成 linux kernel 2.6支持在mount状态下扩容但仅限于ext3文件系统 注意resize2fs操作的先后顺序：在缩容前，记得先执行resize2fs再进行lvreduce；在扩容时，先执行lvextend再进行resize2fs才能生效。好比天气回温脱秋裤，脱之前，咱先得把牛仔裤脱了；天冷加秋裤之后，咱也别忘了把牛仔裤穿回去","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"LVM","slug":"LVM","permalink":"http://wyman.wang/tags/LVM/"},{"name":"Linux","slug":"Linux","permalink":"http://wyman.wang/tags/Linux/"},{"name":"resize2fs","slug":"resize2fs","permalink":"http://wyman.wang/tags/resize2fs/"}]},{"title":"故障：bash. 没有那个文件或目录","slug":"故障：-没有那个文件或目录","date":"2015-04-02T06:53:55.000Z","updated":"2018-04-26T03:13:15.886Z","comments":true,"path":"2015/04/02/故障：-没有那个文件或目录/","link":"","permalink":"http://wyman.wang/2015/04/02/故障：-没有那个文件或目录/","excerpt":"","text":"在ubuntu 中出现 执行某个可执行程序时，提示bash./没有那个文件或目录，ldd查看文件却又提示不是动态可执行文件 原因在于系统为64位，缺少了32为支持库 直接安装32位支持库即可 apt-get install lib32ncurses5apt-get install lib32z1","categories":[],"tags":[]},{"title":"配置RSH无密码访问中遇到的kerberos坑","slug":"配置RSH无密码访问中遇到的kerberos坑","date":"2015-03-28T09:57:20.000Z","updated":"2018-04-26T03:13:15.894Z","comments":true,"path":"2015/03/28/配置RSH无密码访问中遇到的kerberos坑/","link":"","permalink":"http://wyman.wang/2015/03/28/配置RSH无密码访问中遇到的kerberos坑/","excerpt":"","text":"RSH配了半个上午，一直没有成功，简直崩溃。反复了三回之后，我才觉得这事应该无关人品，难道是版本问题？ 用which 查看了一下server端的rsh： which rsh 发现rsh居然存在于kerberos下： 再试着查看一下本机所安装的rsh版本信息： rpm -qf `which rsh` 显示为： 果然幕后黑手是kerberos 用rpm卸载后 立马生效，心情舒畅","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"RSH","slug":"RSH","permalink":"http://wyman.wang/tags/RSH/"},{"name":"kerberos","slug":"kerberos","permalink":"http://wyman.wang/tags/kerberos/"}]},{"title":"脚本实现批量关闭闲置用户的VNC端口","slug":"脚本实现关闭不在线用户的VNC端口","date":"2015-02-02T03:24:47.000Z","updated":"2018-04-26T03:13:15.889Z","comments":true,"path":"2015/02/02/脚本实现关闭不在线用户的VNC端口/","link":"","permalink":"http://wyman.wang/2015/02/02/脚本实现关闭不在线用户的VNC端口/","excerpt":"","text":"VNC是一个利用端口号允许用户远程登录服务器的客户端程序 开启VNC登录端口的用户会在服务器后台运行用户的主控程序Xvnc的进程 但开启后用户长期不登录进程会一直驻留在后台，因此，写了个脚本批量关闭闲置的Xvnc进程： 一、查看现运行的Xvnc进程ps ef |grep Xvnc 第一列及第九列是我们需要的信息，分别为用户名及对用的VNC端口号 使用awk提炼一下，我们要的信息变为： 二、查看目前在线用户1who 可以确定目前正在进行远程登录的用户有哪些 三、关闭不在线用户的Xvnc进程关键命令： 1vncserver -kill :$端口号 当然，执行该命令前必须切换至开启该端口号的用户下 脚本1234567891011121314151617181920#!/bin/bash## To kill the vnc process not using...ps -ef|grep Xvnc|awk '&#123;print $1 $9&#125;' &gt; userport_mapwhile read LINEdo USER=$(echo $LINE | awk -F ':' '&#123;print $1&#125;') #取用户名赋予USER变量 PORT=$(echo $LINE | awk -F ':' '&#123;print $2&#125;') #取相应的端口号赋予PORT变量 w|grep $USER case $? in #通过上条命令执行结果的返回值来判断该用户是否在线：0——在线；1——不在线 1) su $USER -c \"vncserver -kill :$PORT\" #不在线的话，切换至该用户并执行vncserver -kill 命令 echo \"killing $USER \\'s Xvnc process\" esac done &lt; userport_maprm userport_map","categories":[{"name":"shell","slug":"shell","permalink":"http://wyman.wang/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://wyman.wang/tags/shell/"},{"name":"sed","slug":"sed","permalink":"http://wyman.wang/tags/sed/"},{"name":"awk","slug":"awk","permalink":"http://wyman.wang/tags/awk/"},{"name":"VNC","slug":"VNC","permalink":"http://wyman.wang/tags/VNC/"},{"name":"Xvnc","slug":"Xvnc","permalink":"http://wyman.wang/tags/Xvnc/"}]},{"title":"三步配置SSH无密码访问","slug":"三步配置SSH无密码访问","date":"2015-01-04T03:52:27.000Z","updated":"2018-04-26T03:13:15.543Z","comments":true,"path":"2015/01/04/三步配置SSH无密码访问/","link":"","permalink":"http://wyman.wang/2015/01/04/三步配置SSH无密码访问/","excerpt":"","text":"一、ssh-keygen -t rsa二、ssh-add ~/.ssh/id_rsa 可以不用，主要是为了避免出现“Agent admitted failure to sign using the key”的情况 三、ssh-copy-id -i ~/.ssh/id_rsa.pub root@other_node","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[{"name":"ssh无密码访问","slug":"ssh无密码访问","permalink":"http://wyman.wang/tags/ssh无密码访问/"}]},{"title":"在gitbash中使用markdown","slug":"在gitbash中使用markdown","date":"2014-12-07T10:48:30.000Z","updated":"2018-04-26T03:13:15.870Z","comments":true,"path":"2014/12/07/在gitbash中使用markdown/","link":"","permalink":"http://wyman.wang/2014/12/07/在gitbash中使用markdown/","excerpt":"","text":"习惯了通过命令行的方式调用带图形界面的文本编辑器，比如gedit、kwrite在windows的gitbash环境下调取系统下的文本编辑器，也可以通过类似Linux中的修改配置bashrc文件的方式解决： windows下的gitbash配置文件如何找？通过df -kh1df -kh 发现，/目录被挂载在了“C:/Program Files/Git”下，进入“C:/Program Files/Git/etc”目录，发现bash.bashrc文件，添加notepad++可执行程序所在路径：1alias np=\"'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\" 保存后，source一下即可使用np命令使用notepad++ 同理，markdownpad也一样：1alias md=\"'C:\\Program Files (x86)\\MarkdownPad 2\\MarkdownPad2.exe' -multiInst -notabbar -nosession -noPlugin\"","categories":[{"name":"git","slug":"git","permalink":"http://wyman.wang/categories/git/"}],"tags":[{"name":"gitbash","slug":"gitbash","permalink":"http://wyman.wang/tags/gitbash/"},{"name":"markdownpad","slug":"markdownpad","permalink":"http://wyman.wang/tags/markdownpad/"},{"name":"notepad","slug":"notepad","permalink":"http://wyman.wang/tags/notepad/"}]},{"title":"重启后VNC端口号自启动","slug":"重启后VNC端口号自启动","date":"2014-12-03T12:10:52.000Z","updated":"2018-04-26T03:13:15.898Z","comments":true,"path":"2014/12/03/重启后VNC端口号自启动/","link":"","permalink":"http://wyman.wang/2014/12/03/重启后VNC端口号自启动/","excerpt":"","text":"然后编辑/etc/sysconfig/vncservers，以下是文件内容： The VNCSERVERS variable is a list of display:user pairs. # Uncomment the line below to start a VNC server on display :1as my ‘myusername’ (adjust this to your own). You will alsoneed to set a VNC password; run ‘man vncpasswd’ to see howto do that.# DO NOT RUN THIS SERVICE if your local area network isuntrusted! For a secure way of using VNC, seeURL:http://www.uk.research.att.com/vnc/sshvnc.html.VNCSERVERS=”1:user1 2:user2 3:user3”VNCSERVERARGS[1]=”-geometry 1024x768”VNCSERVERARGS[2]=”-geometry 1024x768”VNCSERVERARGS[3]=”-geometry 800x600” 解释一下这个文件： VNCSERVERS这一行是配置在系统启动时启动几个VNC server，上面的例子里运行了三个VNC server，其中user1在display :1，user2在display :2，user3在display :3。 VNCSERVERARGS这三行，分别为VNC server 1, 2, 3配置启动参数，上面的例子里对user1和user2使用屏幕分辨率1024x768，对user3使用800x600。 其它支持的参数请使用“man vncserver”命令查询。 编辑好这个文件后，保存，然后以root身份运行： /sbin/service vncserver start 这样user1, user2, user3的vncserver就启动了。 以后每次系统重启时，都会自动启动这三个用户的vncserver。 注意：上面三个用户必须已经使用vncpasswd命令设置过vnc密码，不然他的vncserver启动会失败","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"}],"tags":[]},{"title":"利用crontab实现SVN的自动化备份","slug":"利用crontab实现SVN的自动化备份","date":"2014-11-25T03:43:31.000Z","updated":"2018-04-26T03:13:15.583Z","comments":true,"path":"2014/11/25/利用crontab实现SVN的自动化备份/","link":"","permalink":"http://wyman.wang/2014/11/25/利用crontab实现SVN的自动化备份/","excerpt":"","text":"svn作为集中式的版本控制系统，由于数据的集中存储，备份是必不可少的; svn的备份机制大致有以下三种： svnadmin dump svnadmin hotcopy svnsync 第一种svnadmin dump是官方推荐的备份方式，优点是比较灵活，可以全量备份也可以增量备份，并提供了版本恢复机制。缺点是：如果版本比较大，如版本数增长到数万、数十万，那么dump的过程将非常慢；备份耗时，恢复更耗时；不利于快速进行灾难恢复。个人建议在版本数比较小的情况下使用这种备份方式。 第二种svnadmin hotcopy原设计目的估计不是用来备份的，只能进行全量拷贝，不能进行增量备份；优点是：备份过程较快，灾难恢复也很快；如果备份机上已经搭建了svn服务，甚至不需要恢复，只需要进行简单配置即可切换到备份库上工作。缺点是：比较耗费硬盘，需要有较大的硬盘支持（俺的备份机有1TB空间，呵呵）。 第三种svnsync实际上是制作2个镜像库，当一个坏了的时候，可以迅速切换到另一个。不过，必须svn1.4版本以上才支持这个功能。优点是：当制作成2个镜像库的时候起到双机实时备份的作用；缺点是：当作为2个镜像库使用时，没办法做到“想完全抛弃今天的修改恢复到昨晚的样子”；而当作为普通备份机制每日备份时，操作又较前2种方法麻烦。————引自头痛不痛的博客 当备份涉及的项目过多，人工备份耗时耗力，我们可以利用系统的cron计划，编写脚本实现svn的自动备份 完全备份12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 #!/bin/bash BACKUP_CMD=\"/usr/bin/svnadmin hotcopy\" #使用svn自带的hotcopy备份机制进行全备份 SVN_LOOK=\"svnlook youngest\" SVN_ROOT=\"/svndata\" SVN_BACKUP_ROOT=/svn_backup BACKUP_DATE=$(date +%Y-%m-%d) cp -rf $SVN_ROOT/passwd $SVN_BACKUP_ROOT cp -rf $SVN_ROOT/authz_bak $SVN_BACKUP_ROOT cp -rf $SVN_ROOT/svnserve_bak $SVN_BACKUP_ROOT #检查目标路径是否存在! if [ ! -e $SVN_BACKUP_ROOT ] then mkdir $SVN_BACKUP_ROOT fi REPO_NAME_LIST=$(ls $SVN_ROOT) #记录版本库名称 #定义logfile LOGFILE=$SVN_BACKUP_ROOT/full_backup.log echo \"====================$BACKUP_DATE========================\" &gt;&gt;$LOGFILE #通过创建的文件夹命名日期来判断备份与否，如果已备份，退出 if [ -e $SVN_BACKUP_ROOT/Full_\"$BACKUP_DATE\" ] then echo \"$(date +%T)==&gt;$SVN_BACKUP_ROOT/Full_\"$BACKUP_DATE\" already exists!\" &gt;&gt;$LOGFILE echo \"Thers is no need backup again!\" &gt;&gt;$LOGFILE exit 1 else mkdir $SVN_BACKUP_ROOT/Full_\"$BACKUP_DATE\" fi #记录备份项目的版本号信息 if [ ! -e $SVN_BACKUP_ROOT/full_repo_revision ] then mkdir $SVN_BACKUP_ROOT/full_repo_revision fi FULL_REPO_VERSION=$SVN_BACKUP_ROOT/full_repo_revision #启动备份 for repo_name in $REPO_NAME_LIST do echo $repo_name SOURCE_DIR=$SVN_ROOT/$repo_name DES_DIR=$SVN_BACKUP_ROOT/Full_\"$BACKUP_DATE\"/$repo_name #get repo version get_repo_version=$($SVN_LOOK $SVN_ROOT/$repo_name) $BACKUP_CMD $SOURCE_DIR $DES_DIR echo \"$(date +%T)==&gt; repository:[$repo_name] at version($get_repo_version) Successfull Full Backup !\" &gt;&gt;$LOGFILE echo \"$get_repo_version\" &gt; $FULL_REPO_VERSION/$repo_name.number done echo \"\" &gt;&gt;$LOGFILE 增量备份与完成备份的脚本差不多1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #!/bin/bash SVN_ROOT=\"/file/svndata\" SVN_BACKUP_ROOT=/svn_backup BK_DATE=$(date +%Y-%m-%d) DUMP=\"svnadmin dump\" #用dump进行增量备份 LOOK=\"svnlook youngest\" #最后用svnlook来判断备份的情况 REPO_NAME_LIST=$(ls $SVN_ROOT) THIS_NUM_FILE=$SVN_BACKUP_ROOT/Increment_\"$BK_DATE\"/repo_version_number LAST_FULL_NUM=$SVN_BACKUP_ROOT/full_repo_revision LOGFILE=$SVN_BACKUP_ROOT/increment_backup.log echo \"=============$(date +%Y-%m-%d_%T)==============\" &gt;&gt;$LOGFILE if [ ! -e $SVN_BACKUP_ROOT/Increment_\"$BK_DATE\" ] then echo \"no Increment Directory , We are making one...\" mkdir $SVN_BACKUP_ROOT/Increment_\"$BK_DATE\" echo \"Increment Directory Created!\" else echo \"$SVN_BACKUP_ROOT/Increment_\"$BK_DATE\" backup directory already exists!\" &gt;&gt;$LOGFILE echo \"There is no need to backup again!!\" &gt;&gt;$LOGFILE exit 1 fi echo \" \"&gt;&gt;$THIS_NUM_FILE echo \"=============$(date +%Y-%m-%d_%T)==============\" &gt;&gt;$THIS_NUM_FILE if [ -e \"$LAST_FULL_NUM\" ] then for repo_name in $REPO_NAME_LIST SOURCE=$SVN_ROOT/$repo_name DEST=$SVN_BACKUP_ROOT/Increment_\"$BK_DATE\"/$repo_name.dumpfile do thisnum=$($LOOK $SVN_ROOT/$repo_name) echo \"The latest rivision of [$repo_name] is : $thisnum\" &gt;&gt;$THIS_NUM_FILE lastnum=$(cat \"$LAST_FULL_NUM\"/\"$repo_name\".number) if [ $thisnum -eq $lastnum ] then echo \"There is no new version for [$repo_name]!!\" &gt;&gt;$LOGFILE else echo \"Increment Backup working... \" $DUMP $SVN_ROOT/$repo_name -r $lastnum:$thisnum --incremental &gt;$SVN_BACKUP_ROOT/Increment_\"$BK_DATE\"/$repo_name.dumpfile echo \"Backup for [$repo_name] from VERSION $lastnum to VERSION $thisnum succeed!\" &gt;&gt;$LOGFILE fi doneecho \" \" &gt;&gt;$LOGFILE 添加至cron计划我们定义备份策略为：每周进行一次增量备份，每周六启动备份；每月进行一次完成备份，每月1号启动备份则crontab可以写为： 1201 02 01 * * /full_bk.sh #在每月第一天的凌晨2:01启动完全备份脚本；01 02 * * 6 /incr_bk.sh #每周六凌晨2:01启动增量备份脚本； （完全备份脚本名为full_bk.sh，增量备份脚本文件名为incr_bk.sh） PS:备份后注意空间的增长","categories":[{"name":"Linux OPS","slug":"Linux-OPS","permalink":"http://wyman.wang/categories/Linux-OPS/"},{"name":"shell","slug":"Linux-OPS/shell","permalink":"http://wyman.wang/categories/Linux-OPS/shell/"}],"tags":[{"name":"svn 备份","slug":"svn-备份","permalink":"http://wyman.wang/tags/svn-备份/"},{"name":"crontab","slug":"crontab","permalink":"http://wyman.wang/tags/crontab/"},{"name":"shell","slug":"shell","permalink":"http://wyman.wang/tags/shell/"}]}]}